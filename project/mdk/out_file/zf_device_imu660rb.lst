C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_imu660rb
OBJECT MODULE PLACED IN .\out_file\zf_device_imu660rb.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_imu660rb.c LARGE NOALIAS FLOAT64 WARN
                    -INGLEVEL(3) OPTIMIZE(3,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_de
                    -vice;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_imu660rb.lst) OBJECT(.\out_file\zf_devi
                    -ce_imu660rb.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library ¼´£¨STC32G ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * STC32G ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MDK FOR C251
   28          * ÊÊÓÃÆ½Ì¨          AI8051U
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33          * 2024-08-01        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * ½ÓÏß¶¨Òå£º
   37          *                   ------------------------------------
   38          *                   Ä£¿é¹Ü½Å            µ¥Æ¬»ú¹Ü½Å
   39          *                   // Ó²¼þ SPI Òý½Å
   40          *                   SCL/SPC           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SPC_PIN ºê¶¨Òå
   41          *                   SDA/DSI           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SDI_PIN ºê¶¨Òå
   42          *                   SA0/SDO           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SDO_PIN ºê¶¨Òå
   43          *                   CS                ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_CS_PIN ºê¶¨Òå
   44          *                   VCC               3.3VµçÔ´
   45          *                   GND               µçÔ´µØ
   46          *                   ÆäÓàÒý½ÅÐü¿Õ
   47          *
   48          *                   // Èí¼þ IIC Òý½Å
   49          *                   SCL/SPC           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SCL_PIN ºê¶¨Òå
   50          *                   SDA/DSI           ²é¿´ zf_device_imu660rb.h ÖÐ IMU660RB_SDA_PIN ºê¶¨Òå
   51          *                   VCC               3.3VµçÔ´
   52          *                   GND               µçÔ´µØ
   53          *                   ÆäÓàÒý½ÅÐü¿Õ
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 2   

   54          *                   ------------------------------------
   55          *********************************************************************************************************
             -***********/
   56          
   57          #include "zf_common_debug.h"
   58          #include "zf_driver_delay.h"
   59          #include "zf_driver_spi.h"
   60          #include "zf_driver_gpio.h"
   61          #include "zf_driver_soft_iic.h"
   62          #include "zf_device_config.h"
   63          #include "zf_device_imu660rb.h"
   64          
   65          int16 imu660rb_gyro_x = 0, imu660rb_gyro_y = 0, imu660rb_gyro_z = 0;            // ÈýÖáÍÓÂÝÒÇÊý¾Ý   gyro 
             -(ÍÓÂÝÒÇ)
   66          int16 imu660rb_acc_x = 0, imu660rb_acc_y = 0, imu660rb_acc_z = 0;               // ÈýÖá¼ÓËÙ¶È¼ÆÊý¾Ý acc  
             -(accelerometer ¼ÓËÙ¶È¼Æ)
   67          
   68          
   69          #if (IMU660RB_USE_INTERFACE==HARDWARE_SPI) 
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     IMU660RB Ð´¼Ä´æÆ÷
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ²ÎÊýËµÃ÷     dat            Êý¾Ý
                       // ·µ»Ø²ÎÊý     void
                       // Ê¹ÓÃÊ¾Àý     imu660rb_write_register(IMU660RB_PWR_CONF, 0x00);                   // ¹Ø±Õ¸ß¼¶Ê¡µçÄ£Ê½
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static void imu660rb_write_register(uint8 reg, uint8 dat)
                       {
                               IMU660RB_CS(0);
                               spi_write_8bit_register(IMU660RB_SPI, reg | IMU660RB_SPI_W, dat);
                               IMU660RB_CS(1);
                       }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     IMU660RB Ð´Êý¾Ý
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ²ÎÊýËµÃ÷     dat            Êý¾Ý
                       // ·µ»Ø²ÎÊý     void
                       // Ê¹ÓÃÊ¾Àý     imu660rb_write_registers(IMU660RB_INIT_DATA, imu660rb_config_file, sizeof(imu660rb_confi
             -g_file));
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // static void imu660rb_write_registers(uint8 reg, const uint8 *dat, uint32 len)
                       // {
                       //     IMU660RB_CS(0);
                       //     spi_write_8bit_registers(IMU660RB_SPI, reg | IMU660RB_SPI_W, dat, len);
                       //     IMU660RB_CS(1);
                       // }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     IMU660RB ¶Á¼Ä´æÆ÷
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
                       // Ê¹ÓÃÊ¾Àý     imu660rb_read_register(IMU660RB_CHIP_ID);
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static uint8 imu660rb_read_register(uint8 reg)
                       {
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 3   

                               uint8 dat;
                               IMU660RB_CS(0);
                               dat = spi_read_8bit_register(IMU660RB_SPI, reg | IMU660RB_SPI_R);
                               IMU660RB_CS(1);
                               return dat;
                       }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     IMU660RB ¶ÁÊý¾Ý
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ²ÎÊýËµÃ÷     dat            Êý¾Ý»º³åÇø
                       // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
                       // ·µ»Ø²ÎÊý     void
                       // Ê¹ÓÃÊ¾Àý     imu660rb_read_registers(IMU660RB_ACC_ADDRESS, dat, 6);
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static void imu660rb_read_registers(uint8 reg, uint8 *dat, uint32 len)
                       {
                               IMU660RB_CS(0);
                               spi_read_8bit_registers(IMU660RB_SPI, reg | IMU660RB_SPI_R, dat, len);
                               IMU660RB_CS(1);
               
                       }
               
               #elif (IMU660RB_USE_INTERFACE==SOFT_SPI)
  135                  
  136                  
  137                  #define IMU660RB_SCK(x)                         IMU660RB_SPC_PIN  = x
  138                  #define IMU660RB_MOSI(x)                        IMU660RB_SDI_PIN = x
  139                  #define IMU660RB_MISO                           IMU660RB_SDO_PIN
  140                  #define IMU660RB_CS(x)                          IMU660RB_CS_PIN  = x
  141          
  142                  //------------------------------------------------------------------------------------------------------
             --------------
  143                  //  @brief      Í¨¹ýSPIÐ´Ò»¸öbyte,Í¬Ê±¶ÁÈ¡Ò»¸öbyte
  144                  //  @param      byte        ·¢ËÍµÄÊý¾Ý
  145                  //  @return     uint8 edata       return ·µ»Østatus×´Ì¬
  146                  //  @since      v1.0
  147                  //  Sample usage:
  148                  //------------------------------------------------------------------------------------------------------
             --------------
  149                  static uint8 imu660rb_simspi_wr_byte(uint8 byte)
  150                  {
  151   1                      uint8 i;
  152   1                      for(i=0; i<8; i++)
  153   1                      {
  154   2                              IMU660RB_SCK (0);
  155   2                              IMU660RB_MOSI(byte&0x80);
  156   2                              byte <<= 1;
  157   2                              IMU660RB_SCK (1);
  158   2                              byte |= IMU660RB_MISO;
  159   2                      }
  160   1                      IMU660RB_SCK (0);
  161   1                      return(byte);
  162   1              }
  163                  
  164                  //------------------------------------------------------------------------------------------------------
             --------------
  165                  //  @brief      ½«valÐ´Èëcmd¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·,Í¬Ê±·µ»Østatus×Ö½Ú
  166                  //  @param      cmd         ÃüÁî×Ö
  167                  //  @param      val         ´ýÐ´Èë¼Ä´æÆ÷µÄÊýÖµ
  168                  //  @since      v1.0
  169                  //  Sample usage:
  170                  //------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 4   

             --------------
  171                  static void imu660rb_simspi_w_reg_byte(uint8 cmd, uint8 val)
  172                  {
  173   1                      cmd |= IMU660RB_SPI_W;
  174   1                      imu660rb_simspi_wr_byte(cmd);
  175   1                      imu660rb_simspi_wr_byte(val);
  176   1              }
  177          
  178                  //------------------------------------------------------------------------------------------------------
             --------------
  179                  //  @brief      ¶ÁÈ¡cmdËù¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  180                  //  @param      cmd         ÃüÁî×Ö
  181                  //  @param      *val        ´æ´¢¶ÁÈ¡µÄÊý¾ÝµØÖ·
  182                  //  @since      v1.0
  183                  //  Sample usage:
  184                  //------------------------------------------------------------------------------------------------------
             --------------
  185                  static void imu660rb_simspi_r_reg_byte(uint8 cmd, uint8 *val)
  186                  {
  187   1                      IMU660RB_SCK(0);
  188   1                      cmd |= IMU660RB_SPI_R;
  189   1                      imu660rb_simspi_wr_byte(cmd);
  190   1                      *val = imu660rb_simspi_wr_byte(0);
  191   1                      IMU660RB_SCK(1);
  192   1              }
  193                  
  194          
  195          //      //----------------------------------------------------------------------------------------------------
             ----------------
  196          //      //  @brief      ½«valÐ´Èëcmd¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  197          //      //  @param      cmd         ÃüÁî×Ö
  198          //      //  @param      val         ´ýÐ´Èë¼Ä´æÆ÷µÄÊýÖµ
  199          //      //  @since      v1.0
  200          //      //  Sample usage:
  201          //      //----------------------------------------------------------------------------------------------------
             ----------------
  202          //      static void imu660rb_simspi_w_reg_bytes(uint8 cmd, uint8 *dat_addr, uint32 len)
  203          //      {
  204          //              cmd |= IMU660RB_SPI_W;
  205          //              imu660rb_simspi_wr_byte(cmd);
  206          //              while(len--)
  207          //              {
  208          //                      imu660rb_simspi_wr_byte(*dat_addr++);
  209          //              }
  210          //      }
  211          
  212                  //------------------------------------------------------------------------------------------------------
             --------------
  213                  //  @brief      ¶ÁÈ¡cmdËù¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  214                  //  @param      cmd         ÃüÁî×Ö
  215                  //  @param      *val        ´æ´¢¶ÁÈ¡µÄÊý¾ÝµØÖ·
  216                  //  @param      num         ¶ÁÈ¡µÄÊýÁ¿
  217                  //  @since      v1.0
  218                  //  Sample usage:
  219                  //------------------------------------------------------------------------------------------------------
             --------------
  220                  static void imu660rb_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  221                  {
  222   1                      cmd |= IMU660RB_SPI_R;
  223   1                      imu660rb_simspi_wr_byte(cmd);
  224   1                      while(num--)
  225   1                      {
  226   2                              *val++ = imu660rb_simspi_wr_byte(0);
  227   2                      }
  228   1              }
  229                  
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 5   

  230                  //------------------------------------------------------------------------------------------------------
             --------------
  231                  // º¯Êý¼ò½é     IMU660RB Ð´¼Ä´æÆ÷
  232                  // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  233                  // ²ÎÊýËµÃ÷     dat            Êý¾Ý
  234                  // ·µ»Ø²ÎÊý     void
  235                  // Ê¹ÓÃÊ¾Àý     imu660rb_write_register(IMU660RB_PWR_CONF, 0x00);                   // ¹Ø±Õ¸ß¼¶Ê¡µçÄ£Ê½
  236                  // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  237                  //------------------------------------------------------------------------------------------------------
             --------------
  238                  static void imu660rb_write_register(uint8 reg, uint8 dat)
  239                  {
  240   1                      IMU660RB_CS(0);
  241   1                      imu660rb_simspi_w_reg_byte(reg | IMU660RB_SPI_W, dat);
  242   1                      IMU660RB_CS(1);
  243   1              }
  244          
  245                  //------------------------------------------------------------------------------------------------------
             --------------
  246                  // º¯Êý¼ò½é     IMU660RB ¶Á¼Ä´æÆ÷
  247                  // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  248                  // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
  249                  // Ê¹ÓÃÊ¾Àý     imu660rb_read_register(IMU660RB_CHIP_ID);
  250                  // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  251                  //------------------------------------------------------------------------------------------------------
             --------------
  252                  static uint8 imu660rb_read_register(uint8 reg)
  253                  {
  254   1                      uint8 dat;
  255   1                      IMU660RB_CS(0);
  256   1                      imu660rb_simspi_r_reg_byte(reg | IMU660RB_SPI_R, &dat);
  257   1                      IMU660RB_CS(1);
  258   1                      return dat;
  259   1              }
  260          
  261                  //------------------------------------------------------------------------------------------------------
             --------------
  262                  // º¯Êý¼ò½é     IMU660RB ¶ÁÊý¾Ý
  263                  // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  264                  // ²ÎÊýËµÃ÷     dat            Êý¾Ý»º³åÇø
  265                  // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
  266                  // ·µ»Ø²ÎÊý     void
  267                  // Ê¹ÓÃÊ¾Àý     imu660rb_read_registers(IMU660RB_ACC_ADDRESS, dat, 6);
  268                  // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  269                  //------------------------------------------------------------------------------------------------------
             --------------
  270                  static void imu660rb_read_registers(uint8 reg, uint8 *dat, uint32 len)
  271                  {
  272   1                      IMU660RB_CS(0);
  273   1                      imu660rb_simspi_r_reg_bytes(reg | IMU660RB_SPI_R, dat, len);
  274   1                      IMU660RB_CS(1);
  275   1              }
  276                  
  277                  
  278          
  279          #elif (IMU660RB_USE_INTERFACE==SOFT_IIC)
                       
                       static soft_iic_info_struct imu660rb_iic_struct;
               
                       #define imu660rb_write_register(reg, dat)        (soft_iic_write_8bit_register (&imu660rb_iic_struct, (r
             -eg), (dat)))
                       #define imu660rb_write_registers(reg, dat, len)  (soft_iic_write_8bit_registers(&imu660rb_iic_struct, (r
             -eg), (dat), (len)))
                       #define imu660rb_read_register(reg)               (soft_iic_read_8bit_register  (&imu660rb_iic_struct, (
             -reg)))
                       #define imu660rb_read_registers(reg, dat, len)   (soft_iic_read_8bit_registers (&imu660rb_iic_struct, (r
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 6   

             -eg), (dat), (len)))
               
               #endif
  289          
  290          //-------------------------------------------------------------------------------------------------------
             -------------
  291          // º¯Êý¼ò½é     IMU660RB ×Ô¼ì
  292          // ²ÎÊýËµÃ÷     void
  293          // ·µ»Ø²ÎÊý     uint8           1-×Ô¼ìÊ§°Ü 0-×Ô¼ì³É¹¦
  294          // Ê¹ÓÃÊ¾Àý     imu660rb_self_check();
  295          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  296          //-------------------------------------------------------------------------------------------------------
             -------------
  297          static uint8 imu660rb_self_check (void)
  298          {
  299   1          uint8 dat = 0, return_state = 0;
  300   1          uint16 timeout_count = 0;
  301   1          do
  302   1          {
  303   2              if(timeout_count ++ > IMU660RB_TIMEOUT_COUNT)
  304   2              {
  305   3                  return_state =  1;
  306   3                  break;
  307   3              }
  308   2              dat = imu660rb_read_register(IMU660RB_CHIP_ID);
  309   2              system_delay_ms(1);
  310   2          }while(0x6B != dat);                                                        // ¶ÁÈ¡Éè±¸IDÊÇ·ñµÈÓÚ0X24
             -£¬Èç¹û²»ÊÇ0X24ÔòÈÏÎªÃ»¼ì²âµ½Éè±¸
  311   1          return return_state;
  312   1      }
  313          
  314          //-------------------------------------------------------------------------------------------------------
             -------------
  315          // º¯Êý¼ò½é     »ñÈ¡ IMU660RB ¼ÓËÙ¶È¼ÆÊý¾Ý
  316          // ²ÎÊýËµÃ÷     void
  317          // ·µ»Ø²ÎÊý     void
  318          // Ê¹ÓÃÊ¾Àý     imu660rb_get_acc();                                             // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  319          // ±¸×¢ÐÅÏ¢     Ê¹ÓÃ SPI µÄ²É¼¯Ê±¼äÎª69us
  320          //             Ê¹ÓÃ IIC µÄ²É¼¯Ê±¼äÎª126us        ²É¼¯¼ÓËÙ¶È¼ÆµÄÊ±¼äÓë²É¼¯ÍÓÂÝÒÇµÄÊ±¼äÒ»ÖÂµÄÔ­ÒòÊÇ¶¼Ö»ÊÇ¶Á
             -È¡¼Ä´æÆ÷Êý¾Ý
  321          //-------------------------------------------------------------------------------------------------------
             -------------
  322          void imu660rb_get_acc (void)
  323          {
  324   1          uint8 dat[6];
  325   1      
  326   1          imu660rb_read_registers(IMU660RB_ACC_ADDRESS, dat, 6);
  327   1          imu660rb_acc_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
  328   1          imu660rb_acc_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
  329   1          imu660rb_acc_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
  330   1      }
  331          //-------------------------------------------------------------------------------------------------------
             -------------
  332          // º¯Êý¼ò½é     »ñÈ¡ IMU660RB ÍÓÂÝÒÇÊý¾Ý
  333          // ²ÎÊýËµÃ÷     void
  334          // ·µ»Ø²ÎÊý     void
  335          // Ê¹ÓÃÊ¾Àý     imu660rb_get_gyro();                                            // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  336          // ±¸×¢ÐÅÏ¢     Ê¹ÓÃ SPI µÄ²É¼¯Ê±¼äÎª69us
  337          //             Ê¹ÓÃ IIC µÄ²É¼¯Ê±¼äÎª126us
  338          //-------------------------------------------------------------------------------------------------------
             -------------
  339          void imu660rb_get_gyro (void)
  340          {
  341   1          uint8 dat[6];
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 7   

  342   1      
  343   1          imu660rb_read_registers(IMU660RB_GYRO_ADDRESS, dat, 6);
  344   1          imu660rb_gyro_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
  345   1          imu660rb_gyro_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
  346   1          imu660rb_gyro_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
  347   1      }
  348          
  349          //-------------------------------------------------------------------------------------------------------
             -------------
  350          // º¯Êý¼ò½é     ½« IMU660RB ¼ÓËÙ¶È¼ÆÊý¾Ý×ª»»ÎªÊµ¼ÊÎïÀíÊý¾Ý
  351          // ²ÎÊýËµÃ÷     gyro_value      ÈÎÒâÖáµÄ¼ÓËÙ¶È¼ÆÊý¾Ý
  352          // ·µ»Ø²ÎÊý     void
  353          // Ê¹ÓÃÊ¾Àý     float dat = imu660rb_acc_transition(imu660rb_acc_x);           // µ¥Î»Îª g(m/s^2)
  354          // ±¸×¢ÐÅÏ¢
  355          //-------------------------------------------------------------------------------------------------------
             -------------
  356          float imu660rb_acc_transition (int16 acc_value)
  357          {
  358   1          float acc_data = 0;
  359   1          switch(IMU660RB_ACC_SAMPLE)
  360   1          {
  361   2              case 0x30: acc_data = (float)acc_value / 16393; break;                  // 0x30 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À2G
             -      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 16393 £¬¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  362   2              case 0x38: acc_data = (float)acc_value / 8197;  break;                  // 0x38 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À4G
             -      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 8197 £¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  363   2              case 0x3C: acc_data = (float)acc_value / 4098;  break;                  // 0x3C ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À8G
             -      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 4098 £¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  364   2              case 0x34: acc_data = (float)acc_value / 2049;  break;                  // 0x34 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À16
             -G     »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ 2049 £¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»£ºg(m/s^2)
  365   2              default: break;
  366   2          }
  367   1          return acc_data;
  368   1      }
  369          
  370          //-------------------------------------------------------------------------------------------------------
             -------------
  371          // º¯Êý¼ò½é     ½« IMU660RB ÍÓÂÝÒÇÊý¾Ý×ª»»ÎªÊµ¼ÊÎïÀíÊý¾Ý
  372          // ²ÎÊýËµÃ÷     gyro_value      ÈÎÒâÖáµÄÍÓÂÝÒÇÊý¾Ý
  373          // ·µ»Ø²ÎÊý     void
  374          // Ê¹ÓÃÊ¾Àý     float dat = imu660rb_gyro_transition(imu660rb_gyro_x);         // µ¥Î»Îª¡ã/s
  375          // ±¸×¢ÐÅÏ¢
  376          //-------------------------------------------------------------------------------------------------------
             -------------
  377          float imu660rb_gyro_transition (int16 gyro_value)
  378          {
  379   1          float gyro_data = 0;
  380   1          switch(IMU660RB_GYR_SAMPLE)
  381   1          {
  382   2              case 0x52: gyro_data = (float)gyro_value / 228.6f;  break;              //  0x52 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À1
             -25dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 228.6£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  383   2              case 0x50: gyro_data = (float)gyro_value / 114.3f;  break;              //  0x50 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À2
             -50dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 114.3£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  384   2              case 0x54: gyro_data = (float)gyro_value / 57.1f;   break;              //  0x54 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À5
             -00dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 57.1£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  385   2              case 0x58: gyro_data = (float)gyro_value / 28.6f;   break;              //  0x58 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À1
             -000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 28.6£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  386   2              case 0x5C: gyro_data = (float)gyro_value / 14.3f;   break;              //  0x5C ÍÓÂÝÒÇÁ¿³ÌÎª:¡À2
             -000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 14.3£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  387   2              case 0x51: gyro_data = (float)gyro_value / 7.1f;    break;              //  0x51 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À4
             -000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 7.1£¬     ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£¬µ¥Î»Îª£º¡ã/s
  388   2              default: break;
  389   2          }
  390   1          return gyro_data;
  391   1      }
  392          
  393          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 8   

             -------------
  394          // º¯Êý¼ò½é     ³õÊ¼»¯ IMU660RB
  395          // ²ÎÊýËµÃ÷     void
  396          // ·µ»Ø²ÎÊý     uint8           1-³õÊ¼»¯Ê§°Ü 0-³õÊ¼»¯³É¹¦
  397          // Ê¹ÓÃÊ¾Àý     imu660rb_init();
  398          // ±¸×¢ÐÅÏ¢
  399          //-------------------------------------------------------------------------------------------------------
             -------------
  400          uint8 imu660rb_init (void)
  401          {
  402   1          uint8 return_state = 0;
  403   1          system_delay_ms(20);                                                        // µÈ´ýÉè±¸ÉÏµç³É¹¦
  404   1      
  405   1      #if (IMU660RB_USE_INTERFACE==HARDWARE_SPI)
                       
                   spi_init(IMU660RB_SPI, SPI_MODE0, IMU660RB_SPI_SPEED, IMU660RB_SPC_PIN, IMU660RB_SDI_PIN, IMU660RB_SD
             -O_PIN, SPI_CS_NULL);   // ÅäÖÃ IMU660RB µÄ SPI ¶Ë¿Ú
                   gpio_init(IMU660RB_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);                  // ÅäÖÃ IMU660RB µÄ CS ¶Ë
             -¿Ú
               //    imu660rb_read_register(IMU660RB_CHIP_ID);                                   // ¶ÁÈ¡Ò»ÏÂÉè±¸ID ½«Éè±
             -¸ÉèÖÃÎªSPIÄ£Ê½
                       
               #elif (IMU660RB_USE_INTERFACE==SOFT_SPI)
  412   1              
  413   1      // Ä¬ÈÏÊ¹ÓÃË«ÏòIO£¬²»ÐèÒª³õÊ¼»¯¡£
  414   1      //      soft_spi_init(IMU660RB_SPI, SPI_MODE0, 0, IMU963RA_SPC_PIN, IMU963RA_SDI_PIN, IMU963RA_SDO_PIN, IMU963
             -RA_CS_PIN);
  415   1              
  416   1      #elif (IMU660RB_USE_INTERFACE==SOFT_IIC)
                       
                       soft_iic_init(&imu660rb_iic_struct, IMU660RB_DEV_ADDR, IMU660RB_SOFT_IIC_DELAY, IMU660RB_SCL_PIN, IMU660
             -RB_SDA_PIN);        // ÅäÖÃ IMU660RB µÄ IIC ¶Ë¿Ú
                       
               #endif
  421   1              
  422   1              
  423   1          do{
  424   2              if(imu660rb_self_check())                                               // IMU660RB ×Ô¼ì
  425   2              {
  426   3                  // Èç¹û³ÌÐòÔÚÊä³öÁË¶ÏÑÔÐÅÏ¢ ²¢ÇÒÌáÊ¾³ö´íÎ»ÖÃÔÚÕâÀï
  427   3                  // ÄÇÃ´¾ÍÊÇ IMU660RB ×Ô¼ì³ö´í²¢³¬Ê±ÍË³öÁË
  428   3                  // ¼ì²éÒ»ÏÂ½ÓÏßÓÐÃ»ÓÐÎÊÌâ Èç¹ûÃ»ÎÊÌâ¿ÉÄÜ¾ÍÊÇ»µÁË
  429   3                  printf("imu660rb self check error.");
  430   3                  return_state = 1;
  431   3                  break;
  432   3              }
  433   2      
  434   2              imu660rb_write_register(IMU660RB_INT1_CTRL, 0x03);                      // ¿ªÆôÍÓÂÝÒÇ ¼ÓËÙ¶ÈÊý¾Ý¾
             -ÍÐ÷ÖÐ¶Ï
  435   2              imu660rb_write_register(IMU660RB_CTRL1_XL, IMU660RB_ACC_SAMPLE);        // ÉèÖÃ¼ÓËÙ¶È¼ÆÁ¿³Ì ¡À8G 
             -ÒÔ¼°Êý¾ÝÊä³öËÙÂÊ 52hz ÒÔ¼°¼ÓËÙ¶ÈÐÅÏ¢´ÓµÚÒ»¼¶ÂË²¨Æ÷Êä³ö
  436   2              // IMU660RB_CTRL1_XL ¼Ä´æÆ÷
  437   2              // ÉèÖÃÎª:0x30 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À2G      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ16393£¬¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  438   2              // ÉèÖÃÎª:0x38 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À4G      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ8197£¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  439   2              // ÉèÖÃÎª:0x3C ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À8G      »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ4098£¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  440   2              // ÉèÖÃÎª:0x34 ¼ÓËÙ¶ÈÁ¿³ÌÎª:¡À16G     »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý ³ýÒÔ2049£¬ ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»£ºg(m/s^2)
  441   2      
  442   2              imu660rb_write_register(IMU660RB_CTRL2_G, IMU660RB_GYR_SAMPLE);         // ÉèÖÃÍÓÂÝÒÇ¼ÆÁ¿³Ì ¡À200
             -0dps ÒÔ¼°Êý¾ÝÊä³öËÙÂÊ 208hz
  443   2              // IMU660RB_CTRL2_G ¼Ä´æÆ÷
  444   2              // ÉèÖÃÎª:0x52 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À125dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ228.6£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
C251 COMPILER V5.60.0,  zf_device_imu660rb                                                 01/10/25  13:12:07  PAGE 9   

  445   2              // ÉèÖÃÎª:0x50 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À250dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ114.3£¬   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  446   2              // ÉèÖÃÎª:0x54 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À500dps  »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ57.1£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  447   2              // ÉèÖÃÎª:0x58 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À1000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ28.6£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  448   2              // ÉèÖÃÎª:0x5C ÍÓÂÝÒÇÁ¿³ÌÎª:¡À2000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ14.3£¬    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  449   2              // ÉèÖÃÎª:0x51 ÍÓÂÝÒÇÁ¿³ÌÎª:¡À4000dps »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ7.1£¬     ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý£
             -¬µ¥Î»Îª£º¡ã/s
  450   2      
  451   2              imu660rb_write_register(IMU660RB_CTRL3_C, 0x44);                        // Ê¹ÄÜÍÓÂÝÒÇÊý×ÖµÍÍ¨ÂË²¨
             -Æ÷
  452   2              imu660rb_write_register(IMU660RB_CTRL4_C, 0x02);                        // Ê¹ÄÜÊý×ÖµÍÍ¨ÂË²¨Æ÷
  453   2              imu660rb_write_register(IMU660RB_CTRL5_C, 0x00);                        // ¼ÓËÙ¶È¼ÆÓëÍÓÂÝÒÇËÄÉáÎå
             -Èë
  454   2              imu660rb_write_register(IMU660RB_CTRL6_C, 0x00);                        // ¿ªÆô¼ÓËÙ¶È¼Æ¸ßÐÔÄÜÄ£Ê½
             - ÍÓÂÝÒÇµÍÍ¨ÂË²¨ 133hz
  455   2              imu660rb_write_register(IMU660RB_CTRL7_G, 0x00);                        // ¿ªÆôÍÓÂÝÒÇ¸ßÐÔÄÜÄ£Ê½ ¹
             -Ø±Õ¸ßÍ¨ÂË²¨
  456   2              imu660rb_write_register(IMU660RB_CTRL9_XL, 0x01);                       // ¹Ø±ÕI3C½Ó¿Ú
  457   2      
  458   2          }while(0);
  459   1          return return_state;
  460   1      }
  461          
  462          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       818     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        12         17
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        69     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
