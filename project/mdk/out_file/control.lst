C251 COMPILER V5.60.0,  control                                                            08/11/25  20:29:02  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\out_file\control.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\control.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) 
                    -BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_drive
                    -r;..\user;..\code) DEBUG PRINT(.\out_file\control.lst) OBJECT(.\out_file\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          
    3          unsigned char CAR_Mode=STOP;
    4          float Left_Speed=0;
    5          float Right_Speed=0;
    6          
    7          float Current_Speed = 0;   // 当前实际输出速度
    8          float Current_dajiao = 0;  
    9          
   10          float d_range = 0.2;
   11          void Ser_Servo_Duty(int value)
   12          {
   13   1          pwm_set_duty(Servo_Pwm,value);
   14   1      }
   15           /*函数：舵机的pid控制
   16           * 作用：利用电磁归一化后的信号控制舵机，
   17           * 参数1：设定的归一化目标值
   18           * 参数2：舵机最小转向值
   19           * 参数3：舵机最大转向值
   20           * 例子：Servo_turn_pid(变量,-80,80);
   21           * 将变量的值与0进行对比，输出信号控制舵机,而舵机的限幅是正负80
   22           */
   23          int Servo_turn_pid(float Current)
   24          {
   25   1          float kp = servo_pid.Kp;           
   26   1          float kd = servo_pid.Kd;
   27   1              
   28   1          float last_error = servo_pid.LastError;
   29   1          float error = Current;
   30   1              float temp;
   31   1          float out = kp * error + kd * (error - last_error); 
   32   1      //    if(abs(error)<d_range)
   33   1      //    {
   34   1      //        return 0;
   35   1      //    }
   36   1          servo_pid.LastError = error;
   37   1          
   38   1          temp = func_limit_ab(out, Servo_min, Servo_max);
   39   1          return (int)(temp + (temp >= 0 ? 0.5f : -0.5f));
   40   1      }
   41          /*
   42          *左电机增量式pi控制器
   43          *
   44          */
   45          int Motor_Left_pi_control(int point)
   46          {
   47   1              float kp=M_left_pid.Kp;
   48   1              float ki=M_left_pid.Ki;
   49   1              float out = 0;
   50   1              
   51   1              int error = point - encoder_data_dir_1;//误差计算
   52   1      
   53   1              float delta_out = kp * (error - M_left_pid.LastError) +//增量计算
   54   1                                                ki * error;
   55   1              delta_out=delta_out> 2000? 2000:delta_out;
   56   1              delta_out=delta_out<-2000?-2000:delta_out;
   57   1              out = M_left_pid.Last_Out + delta_out;
C251 COMPILER V5.60.0,  control                                                            08/11/25  20:29:02  PAGE 2   

   58   1              
   59   1              if(out > 8000) {out = 8000;}
   60   1              else if(out < -8000){out = -8000;}
   61   1              
   62   1              M_left_pid.LastError = error;
   63   1              M_left_pid.Last_Out = out;
   64   1              
   65   1              return (int)out;
   66   1      }
   67          
   68          /*
   69          *右电机增量式pi控制器
   70          *
   71          */
   72          int Motor_Right_pi_control(int point)
   73          {
   74   1              float kp=M_Right_pid.Kp;
   75   1              float ki=M_Right_pid.Ki;
   76   1              float out = 0;
   77   1              
   78   1              int error = point - encoder_data_dir_2;//误差计算
   79   1      
   80   1              float delta_out = kp * (error - M_Right_pid.LastError) +//增量计算
   81   1                                                ki * error;
   82   1              delta_out=delta_out> 2000? 2000:delta_out;
   83   1              delta_out=delta_out<-2000?-2000:delta_out;
   84   1              out = M_Right_pid.Last_Out + delta_out;
   85   1              
   86   1              if(out > 8000) {out = 8000;}
   87   1              else if(out < -8000){out = -8000;}
   88   1              
   89   1              M_Right_pid.LastError = error;
   90   1              M_Right_pid.Last_Out = out;
   91   1              
   92   1              return (int)out;
   93   1      }
   94          /*
   95           * 函数功能：左路电机PWM设置
   96           * 函数名称：MotorL_SetSpeed(unsigned char);
   97           * 输入参数：想要的PWM值
   98           * 输出参数：无
   99           */
  100          void MotorL_SetSpeed(int pwm)
  101          {
  102   1      
  103   1              if(pwm>=0)
  104   1          {
  105   2              pwm_set_duty(MotorL_pwm1,pwm);
  106   2              pwm_set_duty(MotorL_pwm2,0);
  107   2          }
  108   1          else
  109   1          {
  110   2              pwm_set_duty(MotorL_pwm2,-pwm);
  111   2              pwm_set_duty(MotorL_pwm1,0);
  112   2          }
  113   1      }
  114          /*
  115           * 函数功能：右路电机PWM设置
  116           * 函数名称：MotorR_SetSpeed(unsigned char);
  117           * 输入参数：想要的PWM值
  118           * 输出参数：无
  119           */
  120          void MotorR_SetSpeed(int pwm)
  121          {
  122   1          if(pwm>=0)
  123   1          {
C251 COMPILER V5.60.0,  control                                                            08/11/25  20:29:02  PAGE 3   

  124   2              pwm_set_duty(MotorR_pwm1,pwm);
  125   2              pwm_set_duty(MotorR_pwm2,0);
  126   2          }
  127   1          else
  128   1          {
  129   2              pwm_set_duty(MotorR_pwm2,-pwm);
  130   2              pwm_set_duty(MotorR_pwm1,0);
  131   2          }
  132   1      }
  133          /*
  134           * 函数功能：电机驱动更新
  135           * 函数名称：Motor_Update(0);
  136           * 输入参数：无
  137           * 输出参数：无
  138           * 可以进行拓展，写速度策略
  139           */
  140          void Motor_Update(float X)
  141          { 
  142   1                      MotorL_SetSpeed(Motor_Left_pi_control((Left_Speed+X)*100));
  143   1                      MotorR_SetSpeed(Motor_Right_pi_control((Right_Speed+X)*100));
  144   1      }
  145          // 每次调用时将 Current_Speed 缓慢逼近目标速度
  146          void Motor_Update_Smooth(float target)
  147          {
  148   1          float step1 = 0.15;  // 每次变化的最大步长，可以调节平滑程度
  149   1              float step2 = 0.35;
  150   1          if(Current_Speed < target)
  151   1          {
  152   2              Current_Speed += step1;
  153   2              if(Current_Speed > target) Current_Speed = target;
  154   2          }
  155   1          else if(Current_Speed > target)
  156   1          {
  157   2              Current_Speed -= step2;
  158   2              if(Current_Speed < target) Current_Speed = target;
  159   2          }
  160   1          Motor_Update(Current_Speed);  // 实际更新电机
  161   1      }
  162          void PID_Update()
  163          {  
  164   1              switch(CAR_Mode)
  165   1              {
  166   2                      case GO:
  167   2                      {
  168   3                              servo_pid.Kp = KP;
  169   3                              servo_pid.Ki = 0;
  170   3                              servo_pid.Kd = KD;
  171   3                              M_left_pid.Kp = ML_KP;
  172   3                              M_left_pid.Ki = ML_KI;
  173   3                              M_Right_pid.Kp = MR_KP;
  174   3                              M_Right_pid.Ki = MR_KI;
  175   3                      }break;
  176   2                      case GO_Pararm1:
  177   2                      {
  178   3                              servo_pid.Kp = KP1;
  179   3                              servo_pid.Ki = 0;
  180   3                              servo_pid.Kd = KD1;
  181   3                              M_left_pid.Kp = ML_KP1;
  182   3                              M_left_pid.Ki = ML_KI1;
  183   3                              M_Right_pid.Kp = MR_KP1;
  184   3                              M_Right_pid.Ki = MR_KI1;
  185   3                      }break;
  186   2                      case GO_Pararm2:
  187   2                      {
  188   3                              servo_pid.Kp = KP2;
  189   3                              servo_pid.Ki = 0;
C251 COMPILER V5.60.0,  control                                                            08/11/25  20:29:02  PAGE 4   

  190   3                              servo_pid.Kd = KD2;
  191   3                              M_left_pid.Kp = ML_KP2;
  192   3                              M_left_pid.Ki = ML_KI2;
  193   3                              M_Right_pid.Kp = MR_KP2;
  194   3                              M_Right_pid.Ki = MR_KI2;
  195   3                      }break;
  196   2                      case GO_Pararm3:
  197   2                      {
  198   3                              servo_pid.Kp = KP3;
  199   3                              servo_pid.Ki = 0;
  200   3                              servo_pid.Kd = KD3;
  201   3                              M_left_pid.Kp = ML_KP3;
  202   3                              M_left_pid.Ki = ML_KI3;
  203   3                              M_Right_pid.Kp = MR_KP3;
  204   3                              M_Right_pid.Ki = MR_KI3;
  205   3                      }break;
  206   2              }
  207   1              
  208   1      }
  209          
  210          void Cycle_Update(void)
  211          {
  212   1              switch(CAR_Mode)
  213   1              {
  214   2                      case GO:
  215   2                      {
  216   3                              Entern_Flag_Time        =Entern_Flag_Time0              ;
  217   3                              Entern_Delay_Time       =Entern_Delay_Time0             ;
  218   3                              Entern_Continue_Time                    =Entern_Continue_Time0  ;
  219   3                              Mode_Flag                       =Mode_Flag0                             ;
  220   3                              turn_Value                      =turn_Value0                    ;
  221   3                      }break;
  222   2                      case GO_Pararm1:
  223   2                      {
  224   3                              Entern_Flag_Time        =Entern_Flag_Time1              ;
  225   3                              Entern_Delay_Time       =Entern_Delay_Time1             ;
  226   3                              Entern_Continue_Time                    =Entern_Continue_Time1  ;
  227   3                              Mode_Flag                       =Mode_Flag1                             ;
  228   3                              turn_Value                      =turn_Value1                    ;
  229   3                      }break;
  230   2                      case GO_Pararm2:
  231   2                      {
  232   3                              Entern_Flag_Time        =Entern_Flag_Time2              ;
  233   3                              Entern_Delay_Time       =Entern_Delay_Time2             ;
  234   3                              Entern_Continue_Time                    =Entern_Continue_Time2  ;
  235   3                              Mode_Flag                       =Mode_Flag2                             ;
  236   3                              turn_Value                      =turn_Value2                    ;
  237   3                      }break;
  238   2                      case GO_Pararm3:
  239   2                      {
  240   3                              Entern_Flag_Time        =Entern_Flag_Time3              ;
  241   3                              Entern_Delay_Time       =Entern_Delay_Time3             ;
  242   3                              Entern_Continue_Time                    =Entern_Continue_Time3  ;
  243   3                              Mode_Flag                       =Mode_Flag3                             ;
  244   3                              turn_Value                      =turn_Value3                    ;
  245   3                      }break;
  246   2              }
  247   1      }
  248          
  249          /*
  250          //*位置式pi控制
  251          //左路速度环控制
  252          //*/
  253          //int Motor_left_pid(int point)
  254          //{
  255          //    // 将频繁访问的结构体成员加载到局部变量
C251 COMPILER V5.60.0,  control                                                            08/11/25  20:29:02  PAGE 5   

  256          //    float kp = M_left_pid.Kp;       
  257          //      float ki = M_left_pid.Ki;
  258          //    float error = point - encoder_data_dir_1;
  259          //      float out = 0 ;
  260          //      M_left_pid.Out_I += error;
  261          //      if(M_left_pid.Out_I>Motor_Max){M_left_pid.Out_I=Motor_Max;}
  262          //      else if(M_left_pid.Out_I<-Motor_Max){M_left_pid.Out_I=-Motor_Max;}
  263          //    // 使用局部变量计算
  264          //    out = kp * error + ki * M_left_pid.Out_I;
  265          //    if (out > 8000) out = 8000;
  266          //      else if (out < -8000) out = -8000;
  267          //    return (int)(out);
  268          //}
  269          ///*
  270          //*位置式pi控制
  271          //右路速度环控制
  272          //*/
  273          
  274          //int Motor_Right_pid(int point)
  275          //{
  276          //    // 将频繁访问的结构体成员加载到局部变量
  277          //    float kp = M_Right_pid.Kp;       
  278          //      float ki = M_Right_pid.Ki;
  279          //    float error = point - encoder_data_dir_2;
  280          //      float out = 0 ;
  281          //    M_Right_pid.Out_I += error;
  282          //      if(M_Right_pid.Out_I>Motor_Max){M_Right_pid.Out_I=Motor_Max;}
  283          //      else if(M_Right_pid.Out_I<-Motor_Max){M_Right_pid.Out_I=-Motor_Max;}
  284          //    // 使用局部变量计算
  285          //    out = kp * (error) + ki * (M_Right_pid.Out_I);
  286          //    if (out > 8000) out = 8000;
  287          //      else if (out < -8000) out = -8000;
  288          //    return (int)(out);
  289          //}
  290          
  291          void Speed_diff(float value,float Pargarm)
  292          {
  293   1              switch(CAR_Mode)
  294   1              {
  295   2                      case GO:
  296   2                      {
  297   3                              Left_Speed=ML-value*Pargarm;
  298   3                              Right_Speed=MR+value*Pargarm;
  299   3                              break;
  300   3                      }
  301   2                      case GO_Pararm1:
  302   2                      {
  303   3                              Left_Speed=ML1-value*Pargarm;
  304   3                              Right_Speed=MR1+value*Pargarm;
  305   3                              break;
  306   3                      }
  307   2                      case GO_Pararm2:
  308   2                      {
  309   3                              Left_Speed=ML2-value*Pargarm;
  310   3                              Right_Speed=MR2+value*Pargarm;
  311   3                              break;
  312   3                      }
  313   2                      case GO_Pararm3:
  314   2                      {
  315   3                              Left_Speed=ML3-value*Pargarm;
  316   3                              Right_Speed=MR3+value*Pargarm;
  317   3                              break;
  318   3                      }
  319   2                      default :
  320   2                      {
  321   3                              Left_Speed=0;
C251 COMPILER V5.60.0,  control                                                            08/11/25  20:29:02  PAGE 6   

  322   3                              Right_Speed=0;
  323   3                              M_Right_pid.Last_Out=0;
  324   3                              M_Right_pid.Last_Out=0;
  325   3                      }
  326   2              }
  327   1      }
  328          
  329          void Svero_Update_Smooth(float target)
  330          {
  331   1          float step = 2;  // 每次变化的最大步长，可以调节平滑程度
  332   1          if(Current_dajiao < target)
  333   1          {
  334   2              Current_dajiao += step;
  335   2              if(Current_dajiao > target) Current_dajiao = target;
  336   2          }
  337   1          else if(Current_dajiao > target)
  338   1          {
  339   2              Current_dajiao -= step;
  340   2              if(Current_dajiao < target) Current_dajiao = target;
  341   2          }
  342   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2422     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        21     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        51     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
