C251 COMPILER V5.60.0,  control                                                            13/10/25  21:06:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\out_file\control.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\control.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) 
                    -BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_drive
                    -r;..\user;..\code) DEBUG PRINT(.\out_file\control.lst) OBJECT(.\out_file\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          
    3          unsigned char CAR_Mode=STOP;
    4          void Ser_Servo_Duty(int value)
    5          {
    6   1          pwm_set_duty(Servo_Pwm,value);
    7   1      }
    8           /*函数：舵机的pid控制
    9           * 作用：利用电磁归一化后的信号控制舵机，
   10           * 参数1：设定的归一化目标值
   11           * 参数2：舵机最小转向值
   12           * 参数3：舵机最大转向值
   13           * 例子：Servo_turn_pid(变量,-80,80);
   14           * 将变量的值与0进行对比，输出信号控制舵机,而舵机的限幅是正负80
   15           */
   16          int Servo_turn_pid(float Current)
   17          {
   18   1          float kp = servo_pid.Kp;           
   19   1          float kd = servo_pid.Kd;
   20   1          float last_error = servo_pid.LastError;
   21   1          float error = Current;
   22   1              float temp ;
   23   1          
   24   1          float out = kp * error + kd * (error - last_error);
   25   1          
   26   1          servo_pid.LastError = error;
   27   1          
   28   1          temp = func_limit_ab(out, Servo_min, Servo_max);
   29   1          return (int)(temp + (temp >= 0 ? 0.5f : -0.5f));
   30   1      }
   31          /*
   32          *左电机增量式pi控制器
   33          *
   34          */
   35          int Motor_Left_pi_control(int point)
   36          {
   37   1              float kp=M_left_pid.Kp;
   38   1              float ki=M_left_pid.Ki;
   39   1              float out = 0;
   40   1              
   41   1              int error = point - encoder_data_dir_1;//误差计算
   42   1      
   43   1              float delta_out = kp * (error - M_left_pid.LastError) +//增量计算
   44   1                                                ki * error;
   45   1              delta_out=delta_out> 1500? 1500:delta_out;
   46   1              delta_out=delta_out<-1500?-1500:delta_out;
   47   1              out = M_left_pid.Last_Out + delta_out;
   48   1              
   49   1              if(out > 8000) {out = 8000;}
   50   1              else if(out < -8000){out = -8000;}
   51   1              
   52   1              M_left_pid.LastError = error;
   53   1              M_left_pid.Last_Out = out;
   54   1              
   55   1              return (int)out;
   56   1      }
   57          
C251 COMPILER V5.60.0,  control                                                            13/10/25  21:06:33  PAGE 2   

   58          /*
   59          *右电机增量式pi控制器
   60          *
   61          */
   62          int Motor_Right_pi_control(int point)
   63          {
   64   1              float kp=M_Right_pid.Kp;
   65   1              float ki=M_Right_pid.Ki;
   66   1              float out = 0;
   67   1              
   68   1              int error = point - encoder_data_dir_2;//误差计算
   69   1      
   70   1              float delta_out = kp * (error - M_Right_pid.LastError) +//增量计算
   71   1                                                ki * error;
   72   1              delta_out=delta_out> 1500? 1500:delta_out;
   73   1              delta_out=delta_out<-1500?-1500:delta_out;
   74   1              out = M_Right_pid.Last_Out + delta_out;
   75   1              
   76   1              if(out > 8000) {out = 8000;}
   77   1              else if(out < -8000){out = -8000;}
   78   1              
   79   1              M_Right_pid.LastError = error;
   80   1              M_Right_pid.Last_Out = out;
   81   1              
   82   1              return (int)out;
   83   1      }
   84          /*
   85           * 函数功能：左路电机PWM设置
   86           * 函数名称：MotorL_SetSpeed(unsigned char);
   87           * 输入参数：想要的PWM值
   88           * 输出参数：无
   89           */
   90          void MotorL_SetSpeed(int pwm)
   91          {
   92   1      
   93   1              if(pwm>=0)
   94   1          {
   95   2              pwm_set_duty(MotorL_pwm1,pwm);
   96   2              pwm_set_duty(MotorL_pwm2,0);
   97   2          }
   98   1          else
   99   1          {
  100   2              pwm_set_duty(MotorL_pwm2,-pwm);
  101   2              pwm_set_duty(MotorL_pwm1,0);
  102   2          }
  103   1      }
  104          /*
  105           * 函数功能：右路电机PWM设置
  106           * 函数名称：MotorR_SetSpeed(unsigned char);
  107           * 输入参数：想要的PWM值
  108           * 输出参数：无
  109           */
  110          void MotorR_SetSpeed(int pwm)
  111          {
  112   1          if(pwm>=0)
  113   1          {
  114   2              pwm_set_duty(MotorR_pwm1,pwm);
  115   2              pwm_set_duty(MotorR_pwm2,0);
  116   2          }
  117   1          else
  118   1          {
  119   2              pwm_set_duty(MotorR_pwm2,-pwm);
  120   2              pwm_set_duty(MotorR_pwm1,0);
  121   2          }
  122   1      }
  123          /*
C251 COMPILER V5.60.0,  control                                                            13/10/25  21:06:33  PAGE 3   

  124           * 函数功能：电机驱动更新
  125           * 函数名称：Motor_Update(0);
  126           * 输入参数：无
  127           * 输出参数：无
  128           * 可以进行拓展，写速度策略
  129           */
  130          void Motor_Update(char X)
  131          { 
  132   1              switch(CAR_Mode)
  133   1              {
  134   2                      case GO:
  135   2                      {
  136   3                              MotorL_SetSpeed(Motor_Left_pi_control((ML+X)*100));
  137   3                              MotorR_SetSpeed(Motor_Right_pi_control((MR+X)*100));
  138   3      
  139   3                              break;
  140   3                      }       
  141   2                      case GO_Pararm1:
  142   2                      {
  143   3                              MotorL_SetSpeed(Motor_Left_pi_control((ML1+X)*100));
  144   3                              MotorR_SetSpeed(Motor_Right_pi_control((MR1+X)*100));
  145   3                              break;
  146   3                      }       
  147   2                      case GO_Pararm2:
  148   2                      {
  149   3                              MotorL_SetSpeed(Motor_Left_pi_control((ML2+X)*100));
  150   3                              MotorR_SetSpeed(Motor_Right_pi_control((MR2+X)*100));
  151   3                              break;
  152   3                      }       
  153   2                      case GO_Pararm3:
  154   2                      {
  155   3                              MotorL_SetSpeed(Motor_Left_pi_control((ML3+X)*100));
  156   3                              MotorR_SetSpeed(Motor_Right_pi_control((MR3+X)*100));
  157   3                              break;
  158   3                      }               
  159   2                      default:
  160   2                      {
  161   3                              MotorL_SetSpeed(0);
  162   3                              MotorR_SetSpeed(0);
  163   3                              break;
  164   3                      }
  165   2              
  166   2              }
  167   1      }
  168          void PID_Update()
  169          {  
  170   1              switch(CAR_Mode)
  171   1              {
  172   2                      case GO:
  173   2                      {
  174   3                              servo_pid.Kp = KP;
  175   3                              servo_pid.Ki = 0;
  176   3                              servo_pid.Kd = KD;
  177   3                              M_left_pid.Kp = ML_KP;
  178   3                              M_left_pid.Ki = ML_KI;
  179   3                              M_Right_pid.Kp = MR_KP;
  180   3                              M_Right_pid.Ki = MR_KI;
  181   3                      }break;
  182   2                      case GO_Pararm1:
  183   2                      {
  184   3                              servo_pid.Kp = KP1;
  185   3                              servo_pid.Ki = 0;
  186   3                              servo_pid.Kd = KD1;
  187   3                              M_left_pid.Kp = ML_KP1;
  188   3                              M_left_pid.Ki = ML_KI1;
  189   3                              M_Right_pid.Kp = MR_KP1;
C251 COMPILER V5.60.0,  control                                                            13/10/25  21:06:33  PAGE 4   

  190   3                              M_Right_pid.Ki = MR_KI1;
  191   3                      }break;
  192   2                      case GO_Pararm2:
  193   2                      {
  194   3                              servo_pid.Kp = KP2;
  195   3                              servo_pid.Ki = 0;
  196   3                              servo_pid.Kd = KD2;
  197   3                              M_left_pid.Kp = ML_KP2;
  198   3                              M_left_pid.Ki = ML_KI2;
  199   3                              M_Right_pid.Kp = MR_KP2;
  200   3                              M_Right_pid.Ki = MR_KI2;
  201   3                      }break;
  202   2                      case GO_Pararm3:
  203   2                      {
  204   3                              servo_pid.Kp = KP3;
  205   3                              servo_pid.Ki = 0;
  206   3                              servo_pid.Kd = KD3;
  207   3                              M_left_pid.Kp = ML_KP3;
  208   3                              M_left_pid.Ki = ML_KI3;
  209   3                              M_Right_pid.Kp = MR_KP3;
  210   3                              M_Right_pid.Ki = MR_KI3;
  211   3                      }break;
  212   2              }
  213   1              
  214   1      }
  215          
  216          void Cycle_Update(void)
  217          {
  218   1              switch(CAR_Mode)
  219   1              {
  220   2                      case GO:
  221   2                      {
  222   3                              Entern_Flag_Time        =Entern_Flag_Time0              ;
  223   3                              Entern_Delay_Time       =Entern_Delay_Time0             ;
  224   3                              Entern_Continue_Time=Entern_Continue_Time0      ;
  225   3                              Mode_Flag                       =Mode_Flag0                             ;
  226   3                              turn_Value                      =turn_Value0                    ;
  227   3                      }break;
  228   2                      case GO_Pararm1:
  229   2                      {
  230   3                              Entern_Flag_Time        =Entern_Flag_Time1              ;
  231   3                              Entern_Delay_Time       =Entern_Delay_Time1             ;
  232   3                              Entern_Continue_Time=Entern_Continue_Time1      ;
  233   3                              Mode_Flag                       =Mode_Flag1                             ;
  234   3                              turn_Value                      =turn_Value1                    ;
  235   3                      }break;
  236   2                      case GO_Pararm2:
  237   2                      {
  238   3                              Entern_Flag_Time        =Entern_Flag_Time2              ;
  239   3                              Entern_Delay_Time       =Entern_Delay_Time2             ;
  240   3                              Entern_Continue_Time=Entern_Continue_Time2      ;
  241   3                              Mode_Flag                       =Mode_Flag2                             ;
  242   3                              turn_Value                      =turn_Value2                    ;
  243   3                      }break;
  244   2                      case GO_Pararm3:
  245   2                      {
  246   3                              Entern_Flag_Time        =Entern_Flag_Time3              ;
  247   3                              Entern_Delay_Time       =Entern_Delay_Time3             ;
  248   3                              Entern_Continue_Time=Entern_Continue_Time3      ;
  249   3                              Mode_Flag                       =Mode_Flag3                             ;
  250   3                              turn_Value                      =turn_Value3                    ;
  251   3                      }break;
  252   2              }
  253   1      }
  254          
  255          /*
C251 COMPILER V5.60.0,  control                                                            13/10/25  21:06:33  PAGE 5   

  256          //*位置式pi控制
  257          //左路速度环控制
  258          //*/
  259          //int Motor_left_pid(int point)
  260          //{
  261          //    // 将频繁访问的结构体成员加载到局部变量
  262          //    float kp = M_left_pid.Kp;       
  263          //      float ki = M_left_pid.Ki;
  264          //    float error = point - encoder_data_dir_1;
  265          //      float out = 0 ;
  266          //      M_left_pid.Out_I += error;
  267          //      if(M_left_pid.Out_I>Motor_Max){M_left_pid.Out_I=Motor_Max;}
  268          //      else if(M_left_pid.Out_I<-Motor_Max){M_left_pid.Out_I=-Motor_Max;}
  269          //    // 使用局部变量计算
  270          //    out = kp * error + ki * M_left_pid.Out_I;
  271          //    if (out > 8000) out = 8000;
  272          //      else if (out < -8000) out = -8000;
  273          //    return (int)(out);
  274          //}
  275          ///*
  276          //*位置式pi控制
  277          //右路速度环控制
  278          //*/
  279          
  280          //int Motor_Right_pid(int point)
  281          //{
  282          //    // 将频繁访问的结构体成员加载到局部变量
  283          //    float kp = M_Right_pid.Kp;       
  284          //      float ki = M_Right_pid.Ki;
  285          //    float error = point - encoder_data_dir_2;
  286          //      float out = 0 ;
  287          //    M_Right_pid.Out_I += error;
  288          //      if(M_Right_pid.Out_I>Motor_Max){M_Right_pid.Out_I=Motor_Max;}
  289          //      else if(M_Right_pid.Out_I<-Motor_Max){M_Right_pid.Out_I=-Motor_Max;}
  290          //    // 使用局部变量计算
  291          //    out = kp * (error) + ki * (M_Right_pid.Out_I);
  292          //    if (out > 8000) out = 8000;
  293          //      else if (out < -8000) out = -8000;
  294          //    return (int)(out);
  295          //}


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2076     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =         1     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         6     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
