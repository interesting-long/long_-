C251 COMPILER V5.60.0,  control                                                            12/10/25  22:10:38  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\out_file\control.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\control.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) 
                    -BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_drive
                    -r;..\user;..\code) DEBUG PRINT(.\out_file\control.lst) OBJECT(.\out_file\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          
    3          unsigned char CAR_Mode=STOP;
    4          void Ser_Servo_Duty(int value)
    5          {
    6   1          pwm_set_duty(Servo_Pwm,value);
    7   1      }
    8           /*函数：舵机的pid控制
    9           * 作用：利用电磁归一化后的信号控制舵机，
   10           * 参数1：设定的归一化目标值
   11           * 参数2：舵机最小转向值
   12           * 参数3：舵机最大转向值
   13           * 例子：Servo_turn_pid(变量,-80,80);
   14           * 将变量的值与0进行对比，输出信号控制舵机,而舵机的限幅是正负80
   15           */
   16          int Servo_turn_pid(float Current)
   17          {
   18   1          float kp = servo_pid.Kp;           
   19   1          float kd = servo_pid.Kd;
   20   1          float last_error = servo_pid.LastError;
   21   1          float error = Current;
   22   1              float temp ;
   23   1          
   24   1          float out = kp * error + kd * (error - last_error);
   25   1          
   26   1          servo_pid.LastError = error;
   27   1          
   28   1          temp = func_limit_ab(out, Servo_min, Servo_max);
   29   1          return (int)(temp + (temp >= 0 ? 0.5f : -0.5f));
   30   1      }
   31          /*
   32          *左路速度环控制
   33          */
   34          int Motor_left_pid(int point)
   35          {
   36   1          // 将频繁访问的结构体成员加载到局部变量
   37   1          float kp = M_left_pid.Kp;       
   38   1              float ki = M_left_pid.Ki;
   39   1          float error = point - encoder_data_dir_1;
   40   1              float out = 0 ;
   41   1              M_left_pid.Out_I += error;
   42   1              if(M_left_pid.Out_I>Motor_Max){M_left_pid.Out_I=Motor_Max;}
   43   1              else if(M_left_pid.Out_I<-Motor_Max){M_left_pid.Out_I=-Motor_Max;}
   44   1          // 使用局部变量计算
   45   1          out = kp * error + ki * M_left_pid.Out_I;
   46   1          if (out > 8000) out = 8000;
   47   1              else if (out < -8000) out = -8000;
   48   1          return (int)(out);
   49   1      }
   50          /*
   51          *右路速度环控制
   52          */
   53          
   54          int Motor_Right_pid(int point)
   55          {
   56   1          // 将频繁访问的结构体成员加载到局部变量
   57   1          float kp = M_Right_pid.Kp;       
C251 COMPILER V5.60.0,  control                                                            12/10/25  22:10:38  PAGE 2   

   58   1              float ki = M_Right_pid.Ki;
   59   1          float error = point - encoder_data_dir_2;
   60   1              float out = 0 ;
   61   1          M_Right_pid.Out_I += error;
   62   1              if(M_Right_pid.Out_I>Motor_Max){M_Right_pid.Out_I=Motor_Max;}
   63   1              else if(M_Right_pid.Out_I<-Motor_Max){M_Right_pid.Out_I=-Motor_Max;}
   64   1          // 使用局部变量计算
   65   1          out = kp * (error) + ki * (M_Right_pid.Out_I);
   66   1          if (out > 8000) out = 8000;
   67   1              else if (out < -8000) out = -8000;
   68   1          return (int)(out);
   69   1      }
   70          /*
   71           * 函数功能：左路电机PWM设置
   72           * 函数名称：MotorL_SetSpeed(unsigned char);
   73           * 输入参数：想要的PWM值
   74           * 输出参数：无
   75           */
   76          void MotorL_SetSpeed(int pwm)
   77          {
   78   1      
   79   1              if(pwm>=0)
   80   1          {
   81   2              pwm_set_duty(MotorL_pwm1,pwm);
   82   2              pwm_set_duty(MotorL_pwm2,0);
   83   2          }
   84   1          else
   85   1          {
   86   2              pwm_set_duty(MotorL_pwm2,-pwm);
   87   2              pwm_set_duty(MotorL_pwm1,0);
   88   2          }
   89   1      }
   90          /*
   91           * 函数功能：右路电机PWM设置
   92           * 函数名称：MotorR_SetSpeed(unsigned char);
   93           * 输入参数：想要的PWM值
   94           * 输出参数：无
   95           */
   96          void MotorR_SetSpeed(int pwm)
   97          {
   98   1          if(pwm>=0)
   99   1          {
  100   2              pwm_set_duty(MotorR_pwm1,pwm);
  101   2              pwm_set_duty(MotorR_pwm2,0);
  102   2          }
  103   1          else
  104   1          {
  105   2              pwm_set_duty(MotorR_pwm2,-pwm);
  106   2              pwm_set_duty(MotorR_pwm1,0);
  107   2          }
  108   1      }
  109          /*
  110           * 函数功能：电机驱动更新
  111           * 函数名称：Motor_Update(0);
  112           * 输入参数：无
  113           * 输出参数：无
  114           * 可以进行拓展，写速度策略
  115           */
  116          void Motor_Update(char X)
  117          { 
  118   1              if(GO_PID_Control+GO_PID_Control1+GO_PID_Control2+GO_PID_Control3==1)
  119   1              {
  120   2                      switch(CAR_Mode)
  121   2                      {
  122   3                              case GO:
  123   3                              {
C251 COMPILER V5.60.0,  control                                                            12/10/25  22:10:38  PAGE 3   

  124   4      //                              if(M_Mod>1)
  125   4      //                              {
  126   4                                      MotorL_SetSpeed(Motor_left_pid((ML+X)*100));
  127   4                                      MotorR_SetSpeed(Motor_Right_pid((MR+X)*100));
  128   4      //                              }
  129   4      //                              else
  130   4      //                              {
  131   4      //                              MotorL_SetSpeed((ML+X)*100);
  132   4      //                              MotorR_SetSpeed((MR+X)*100);
  133   4      //                              }
  134   4                                      break;
  135   4                              }       
  136   3                              case GO_Pararm1:
  137   3                              {
  138   4      //                              if(M_Mod1>1)
  139   4      //                              {
  140   4                                      MotorL_SetSpeed(Motor_left_pid((ML1+X)*100));
  141   4                                      MotorR_SetSpeed(Motor_Right_pid((MR1+X)*100));
  142   4      //                              }
  143   4      //                              else
  144   4      //                              {
  145   4      //                              MotorL_SetSpeed((ML1+X)*100);
  146   4      //                              MotorR_SetSpeed((MR1+X)*100);
  147   4      //                              }
  148   4                                      break;
  149   4                              }       
  150   3                              case GO_Pararm2:
  151   3                              {
  152   4      //                              if(M_Mod2>1)
  153   4      //                              {
  154   4                                      MotorL_SetSpeed(Motor_left_pid((ML2+X)*100));
  155   4                                      MotorR_SetSpeed(Motor_Right_pid((MR2+X)*100));
  156   4      //                              }
  157   4      //                              else
  158   4      //                              {
  159   4      //                              MotorL_SetSpeed((ML2+X)*100);
  160   4      //                              MotorR_SetSpeed((MR2+X)*100);
  161   4      //                              }
  162   4                                      break;
  163   4                              }       
  164   3                              case GO_Pararm3:
  165   3                              {
  166   4      //                              if(M_Mod3>1)
  167   4      //                              {
  168   4                                      MotorL_SetSpeed(Motor_left_pid((ML3+X)*100));
  169   4                                      MotorR_SetSpeed(Motor_Right_pid((MR3+X)*100));
  170   4      //                              }
  171   4      //                              else
  172   4      //                              {
  173   4      //                              MotorL_SetSpeed((ML3+X)*100);
  174   4      //                              MotorR_SetSpeed((MR3+X)*100);
  175   4      //                              }
  176   4                                      break;
  177   4                              }               
  178   3                              default:
  179   3                              {
  180   4                                      MotorL_SetSpeed(0);
  181   4                                      MotorR_SetSpeed(0);
  182   4                                      M_Right_pid.Out_I=0;
  183   4                                      M_left_pid.Out_I=0;
  184   4                                      break;
  185   4                              }
  186   3                      
  187   3                      }
  188   2              }
  189   1              
C251 COMPILER V5.60.0,  control                                                            12/10/25  22:10:38  PAGE 4   

  190   1      }
  191          void PID_Update()
  192          {  
  193   1              switch(CAR_Mode)
  194   1              {
  195   2                      case GO:
  196   2                      {
  197   3                              servo_pid.Kp = KP;
  198   3                              servo_pid.Ki = 0;
  199   3                              servo_pid.Kd = KD;
  200   3                              M_left_pid.Kp = ML_KP;
  201   3                              M_left_pid.Ki = ML_KI;
  202   3                              M_Right_pid.Kp = MR_KP;
  203   3                              M_Right_pid.Ki = MR_KI;
  204   3                      }break;
  205   2                      case GO_Pararm1:
  206   2                      {
  207   3                              servo_pid.Kp = KP1;
  208   3                              servo_pid.Ki = 0;
  209   3                              servo_pid.Kd = KD1;
  210   3                              M_left_pid.Kp = ML_KP1;
  211   3                              M_left_pid.Ki = ML_KI1;
  212   3                              M_Right_pid.Kp = MR_KP1;
  213   3                              M_Right_pid.Ki = MR_KI1;
  214   3                      }break;
  215   2                      case GO_Pararm2:
  216   2                      {
  217   3                              servo_pid.Kp = KP2;
  218   3                              servo_pid.Ki = 0;
  219   3                              servo_pid.Kd = KD2;
  220   3                              M_left_pid.Kp = ML_KP2;
  221   3                              M_left_pid.Ki = ML_KI2;
  222   3                              M_Right_pid.Kp = MR_KP2;
  223   3                              M_Right_pid.Ki = MR_KI2;
  224   3                      }break;
  225   2                      case GO_Pararm3:
  226   2                      {
  227   3                              servo_pid.Kp = KP3;
  228   3                              servo_pid.Ki = 0;
  229   3                              servo_pid.Kd = KD3;
  230   3                              M_left_pid.Kp = ML_KP3;
  231   3                              M_left_pid.Ki = ML_KI3;
  232   3                              M_Right_pid.Kp = MR_KP3;
  233   3                              M_Right_pid.Ki = MR_KI3;
  234   3                      }break;
  235   2              }
  236   1              
  237   1      }
  238          
  239          void Cycle_Update(void)
  240          {
  241   1              switch(CAR_Mode)
  242   1              {
  243   2                      case GO:
  244   2                      {
  245   3                              Entern_Flag_Time        =Entern_Flag_Time0              ;
  246   3                              Entern_Delay_Time       =Entern_Delay_Time0             ;
  247   3                              Entern_Continue_Time=Entern_Continue_Time0      ;
  248   3                              Mode_Flag                       =Mode_Flag0                             ;
  249   3                              turn_Value                      =turn_Value0                    ;
  250   3                      }break;
  251   2                      case GO_Pararm1:
  252   2                      {
  253   3                              Entern_Flag_Time        =Entern_Flag_Time1              ;
  254   3                              Entern_Delay_Time       =Entern_Delay_Time1             ;
  255   3                              Entern_Continue_Time=Entern_Continue_Time1      ;
C251 COMPILER V5.60.0,  control                                                            12/10/25  22:10:38  PAGE 5   

  256   3                              Mode_Flag                       =Mode_Flag1                             ;
  257   3                              turn_Value                      =turn_Value1                    ;
  258   3                      }break;
  259   2                      case GO_Pararm2:
  260   2                      {
  261   3                              Entern_Flag_Time        =Entern_Flag_Time2              ;
  262   3                              Entern_Delay_Time       =Entern_Delay_Time2             ;
  263   3                              Entern_Continue_Time=Entern_Continue_Time2      ;
  264   3                              Mode_Flag                       =Mode_Flag2                             ;
  265   3                              turn_Value                      =turn_Value2                    ;
  266   3                      }break;
  267   2                      case GO_Pararm3:
  268   2                      {
  269   3                              Entern_Flag_Time        =Entern_Flag_Time3              ;
  270   3                              Entern_Delay_Time       =Entern_Delay_Time3             ;
  271   3                              Entern_Continue_Time=Entern_Continue_Time3      ;
  272   3                              Mode_Flag                       =Mode_Flag3                             ;
  273   3                              turn_Value                      =turn_Value3                    ;
  274   3                      }break;
  275   2              }
  276   1      }
  277          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2127     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =         1     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         6     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
