C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_icm20602
OBJECT MODULE PLACED IN .\out_file\zf_device_icm20602.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_icm20602.c LARGE NOALIAS FLOAT64 WARN
                    -INGLEVEL(3) OPTIMIZE(3,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_de
                    -vice;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_icm20602.lst) OBJECT(.\out_file\zf_devi
                    -ce_icm20602.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library ¼´£¨AI8051U ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈý·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öð·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼þÊÇSTC ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * AI8051U ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼þ
    8          * Äú¿ÉÒÔ¸ù¾Ý×ÔÓÉÈí¼þ»ù½ð»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ðí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØÐÂ·¢²¼ºÍ/»òÐÞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓÐÒþº¬µÄÊÊÏúÐÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·Ý GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓÐ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ðí¿ÉÖ¤Ð­Òé ÒÔÉÏÐí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ðí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼þ¼ÐÏÂµÄ GPL3_permission_statement.txt ÎÄ¼þÖÐ
   21          * Ðí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼þ¼ÐÏÂ ¼´¸ÃÎÄ¼þ¼ÐÏÂµÄ LICENSE ÎÄ¼þ
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌÐò µ«ÐÞ¸ÄÄÚÈÝÊ±±ØÐë±£ÁôÖð·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼þÃû³Æ          
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öð·É¿Æ¼¼ÓÐÏÞ¹«Ë¾
   26          * °æ±¾ÐÅÏ¢          ²é¿´ libraries/doc ÎÄ¼þ¼ÐÄÚ version ÎÄ¼þ °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MDK FOR C251
   28          * ÊÊÓÃÆ½Ì¨          AI8051U
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ÐÞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ              ×÷Õß           ±¸×¢
   33          * 2024-08-01        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * ½ÓÏß¶¨Òå:
   37          *                   ------------------------------------
   38          *                   Ä£¿é¹Ü½Å                                        µ¥Æ¬»ú¹Ü½Å
   39          *                   //------------------Ó²¼þ SPI Òý½Å------------------//
   40          *                   SCL/SPC             ²é¿´ zf_device_icm20602.h ÖÐ ICM20602_SPC_PIN ºê¶¨Òå
   41          *                   SDA/DSI             ²é¿´ zf_device_icm20602.h ÖÐ ICM20602_SDI_PIN ºê¶¨Òå
   42          *                   SA0/SDO             ²é¿´ zf_device_icm20602.h ÖÐ ICM20602_SDO_PIN ºê¶¨Òå
   43          *                   CS                  ²é¿´ zf_device_icm20602.h ÖÐ IPS114_CS_PIN ºê¶¨Òå
   44          *                   //------------------Ó²¼þ SPI Òý½Å------------------//
   45          *                   //------------------Èí¼þ IIC Òý½Å------------------//
   46          *                   SCL/SPC             ²é¿´ zf_device_icm20602.h ÖÐ ICM20602_SCL_PIN ºê¶¨Òå
   47          *                   SDA/DSI             ²é¿´ zf_device_icm20602.h ÖÐ ICM20602_SDA_PIN ºê¶¨Òå
   48          *                   //------------------Èí¼þ IIC Òý½Å------------------//
   49          *                   µçÔ´Òý½Å
   50          *                   VCC                 3.3VµçÔ´
   51          *                   GND                 µçÔ´µØ
   52          *                   ------------------------------------
   53          *********************************************************************************************************
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 2   

             -***********/
   54          
   55          #include "zf_common_clock.h"
   56          #include "zf_common_debug.h"
   57          #include "zf_driver_delay.h"
   58          #include "zf_driver_spi.h"
   59          #include "zf_driver_soft_iic.h"
   60          #include "zf_driver_soft_spi.h"
   61          
   62          #include "zf_device_icm20602.h"
   63          
   64          #pragma warning disable = 183
   65          #pragma warning disable = 177
   66          
   67          int16 icm20602_gyro_x = 0, icm20602_gyro_y = 0, icm20602_gyro_z = 0;            // ÈýÖáÍÓÂÝÒÇÊý¾Ý      gy
             -ro (ÍÓÂÝÒÇ)
   68          int16 icm20602_acc_x = 0, icm20602_acc_y = 0, icm20602_acc_z = 0;               // ÈýÖá¼ÓËÙ¶È¼ÆÊý¾Ý    ac
             -c (accelerometer ¼ÓËÙ¶È¼Æ)
   69          float icm20602_transition_factor[2] = {4096, 16.4};
   70          
   71          #if (ICM20602_USE_INTERFACE==HARDWARE_SPI)                               // ÕâÁ½¶Î ÑÕÉ«Õý³£µÄ²ÅÊÇÕýÈ·µÄ Ñ
             -ÕÉ«»ÒµÄ¾ÍÊÇÃ»ÓÐÓÃµÄ
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     ICM20602 Ð´¼Ä´æÆ÷
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ²ÎÊýËµÃ÷     data            Êý¾Ý
                       // ·µ»Ø²ÎÊý     void
                       // Ê¹ÓÃÊ¾Àý     icm20602_write_register(ICM20602_PWR_MGMT_1, 0x80);
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static void icm20602_write_register (uint8 reg, uint8 dat)
                       {
                               ICM20602_CS(0);
                               spi_write_8bit_register(ICM20602_SPI, reg | ICM20602_SPI_W, dat);
                               ICM20602_CS(1);
                       }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     ICM20602 ¶Á¼Ä´æÆ÷
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
                       // Ê¹ÓÃÊ¾Àý     icm20602_read_register(ICM20602_WHO_AM_I);
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static uint8 icm20602_read_register (uint8 reg)
                       {
                               uint8 dat = 0;
                               ICM20602_CS(0);
                               dat = spi_read_8bit_register(ICM20602_SPI, reg | ICM20602_SPI_R);
                               ICM20602_CS(1);
                               return dat;
                       }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     ICM20602 ¶ÁÊý¾Ý
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ²ÎÊýËµÃ÷     data            Êý¾Ý»º³åÇø
                       // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
                       // ·µ»Ø²ÎÊý     void
                       // Ê¹ÓÃÊ¾Àý     icm20602_read_registers(ICM20602_ACCEL_XOUT_H, dat, 6);
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 3   

                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static void icm20602_read_registers (uint8 reg, uint8 *dat, uint32 len)
                       {
                               ICM20602_CS(0);
                               spi_read_8bit_registers(ICM20602_SPI, reg | ICM20602_SPI_R, dat, len);
                               ICM20602_CS(1);
                       }
               
               #elif (ICM20602_USE_INTERFACE==SOFT_SPI)
  121                  #define ICM20602_SCK(x)                         (ICM20602_SPC_PIN       = x)
  122                  #define ICM20602_MOSI(x)                        (ICM20602_SDI_PIN       = x)
  123                  #define ICM20602_MISO                           (ICM20602_SDO_PIN          )
  124                  #define ICM20602_CS(x)              (ICM20602_CS_PIN    = x)
  125                  //------------------------------------------------------------------------------------------------------
             --------------
  126                  //  @brief      Í¨¹ýSPIÐ´Ò»¸öbyte,Í¬Ê±¶ÁÈ¡Ò»¸öbyte
  127                  //  @param      byte        ·¢ËÍµÄÊý¾Ý
  128                  //  @return     uint8 edata       return ·µ»Østatus×´Ì¬
  129                  //  @since      v1.0
  130                  //  Sample usage:
  131                  //------------------------------------------------------------------------------------------------------
             --------------
  132                  static uint8 icm20602_simspi_wr_byte(uint8 byte)
  133                  {
  134   1                      uint8 i;
  135   1                      for(i=0; i<8; i++)
  136   1                      {
  137   2                              ICM20602_SCK (0);
  138   2                              ICM20602_MOSI(byte&0x80);
  139   2                              byte <<= 1;
  140   2                              ICM20602_SCK (1);
  141   2                              byte |= ICM20602_MISO;
  142   2                      }
  143   1                      return(byte);
  144   1              }
  145                  
  146                  //------------------------------------------------------------------------------------------------------
             --------------
  147                  //  @brief      ½«valÐ´Èëcmd¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·,Í¬Ê±·µ»Østatus×Ö½Ú
  148                  //  @param      cmd         ÃüÁî×Ö
  149                  //  @param      val         ´ýÐ´Èë¼Ä´æÆ÷µÄÊýÖµ
  150                  //  @since      v1.0
  151                  //  Sample usage:
  152                  //------------------------------------------------------------------------------------------------------
             --------------
  153                  static void icm20602_simspi_w_reg_byte(uint8 cmd, uint8 val)
  154                  {
  155   1                      cmd |= ICM20602_SPI_W;
  156   1                      icm20602_simspi_wr_byte(cmd);
  157   1                      icm20602_simspi_wr_byte(val);
  158   1              }
  159          
  160                  //------------------------------------------------------------------------------------------------------
             --------------
  161                  //  @brief      ¶ÁÈ¡cmdËù¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  162                  //  @param      cmd         ÃüÁî×Ö
  163                  //  @param      *val        ´æ´¢¶ÁÈ¡µÄÊý¾ÝµØÖ·
  164                  //  @since      v1.0
  165                  //  Sample usage:
  166                  //------------------------------------------------------------------------------------------------------
             --------------
  167                  static void icm20602_simspi_r_reg_byte(uint8 cmd, uint8 *val)
  168                  {
  169   1                      cmd |= ICM20602_SPI_R;
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 4   

  170   1                      icm20602_simspi_wr_byte(cmd);
  171   1                      *val = icm20602_simspi_wr_byte(0);
  172   1              }
  173          
  174                  //------------------------------------------------------------------------------------------------------
             --------------
  175                  //  @brief      ¶ÁÈ¡cmdËù¶ÔÓ¦µÄ¼Ä´æÆ÷µØÖ·
  176                  //  @param      cmd         ÃüÁî×Ö
  177                  //  @param      *val        ´æ´¢¶ÁÈ¡µÄÊý¾ÝµØÖ·
  178                  //  @param      num         ¶ÁÈ¡µÄÊýÁ¿
  179                  //  @since      v1.0
  180                  //  Sample usage:
  181                  //------------------------------------------------------------------------------------------------------
             --------------
  182                  static void icm20602_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  183                  {
  184   1                      uint32 edata i = 0;
  185   1                      cmd |= ICM20602_SPI_R;
  186   1                      icm20602_simspi_wr_byte(cmd);
  187   1                      while(num--)
  188   1                      {
  189   2                              *val++ = icm20602_simspi_wr_byte(0);
  190   2                      }
  191   1              }
  192          
  193                  //------------------------------------------------------------------------------------------------------
             --------------
  194                  // º¯Êý¼ò½é     IMU660RA Ð´¼Ä´æÆ÷
  195                  // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  196                  // ²ÎÊýËµÃ÷     dat            Êý¾Ý
  197                  // ·µ»Ø²ÎÊý     void
  198                  // Ê¹ÓÃÊ¾Àý     icm20602_write_register(ICM20602_PWR_CONF, 0x00);                   // ¹Ø±Õ¸ß¼¶Ê¡µçÄ£Ê½
  199                  // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  200                  //------------------------------------------------------------------------------------------------------
             --------------
  201                  static void icm20602_write_register(uint8 reg, uint8 dat)
  202                  {
  203   1                      ICM20602_CS(0);
  204   1                      icm20602_simspi_w_reg_byte(reg | ICM20602_SPI_W, dat);
  205   1                      ICM20602_CS(1);
  206   1              }
  207          
  208                  //------------------------------------------------------------------------------------------------------
             --------------
  209                  // º¯Êý¼ò½é     IMU660RA ¶Á¼Ä´æÆ÷
  210                  // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  211                  // ·µ»Ø²ÎÊý     uint8 edata           Êý¾Ý
  212                  // Ê¹ÓÃÊ¾Àý     icm20602_read_register(ICM20602_CHIP_ID);
  213                  // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  214                  //------------------------------------------------------------------------------------------------------
             --------------
  215                  static uint8 icm20602_read_register(uint8 reg)
  216                  {
  217   1                      uint8 dat;
  218   1                      ICM20602_CS(0);
  219   1                      icm20602_simspi_r_reg_byte(reg | ICM20602_SPI_R, &dat);
  220   1                      ICM20602_CS(1);
  221   1                      return dat;
  222   1              }
  223          
  224                  //------------------------------------------------------------------------------------------------------
             --------------
  225                  // º¯Êý¼ò½é     IMU660RA ¶ÁÊý¾Ý
  226                  // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
  227                  // ²ÎÊýËµÃ÷     dat            Êý¾Ý»º³åÇø
  228                  // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 5   

  229                  // ·µ»Ø²ÎÊý     void
  230                  // Ê¹ÓÃÊ¾Àý     icm20602_read_registers(ICM20602_ACC_ADDRESS, dat, 6);
  231                  // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  232                  //------------------------------------------------------------------------------------------------------
             --------------
  233                  static void icm20602_read_registers(uint8 reg, uint8 *dat, uint32 len)
  234                  {
  235   1                      ICM20602_CS(0);
  236   1                      icm20602_simspi_r_reg_bytes(reg | ICM20602_SPI_R, dat, len);
  237   1                      ICM20602_CS(1);
  238   1              }
  239          
  240          #elif (ICM20602_USE_INTERFACE==SOFT_IIC)
               
                       static soft_iic_info_struct icm20602_iic_struct;
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     ICM20602 Ð´¼Ä´æÆ÷
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ²ÎÊýËµÃ÷     dat            Êý¾Ý
                       // ·µ»Ø²ÎÊý     void
                       // Ê¹ÓÃÊ¾Àý     icm20602_write_register(ICM20602_PWR_MGMT_1, 0x80);
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       #define icm20602_write_register(reg, dat)      (soft_iic_write_8bit_register(&icm20602_iic_struct, (reg)
             -, (dat)))
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     ICM20602 ¶Á¼Ä´æÆ÷
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ·µ»Ø²ÎÊý     uint8           Êý¾Ý
                       // Ê¹ÓÃÊ¾Àý     icm20602_read_register(ICM20602_WHO_AM_I);
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       #define icm20602_read_register(reg)             (soft_iic_read_8bit_register(&icm20602_iic_struct, (reg)
             -))
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // º¯Êý¼ò½é     ICM20602 ¶ÁÊý¾Ý
                       // ²ÎÊýËµÃ÷     reg             ¼Ä´æÆ÷µØÖ·
                       // ²ÎÊýËµÃ÷     dat            Êý¾Ý»º³åÇø
                       // ²ÎÊýËµÃ÷     len             Êý¾Ý³¤¶È
                       // ·µ»Ø²ÎÊý     void
                       // Ê¹ÓÃÊ¾Àý     icm20602_read_registers(ICM20602_ACCEL_XOUT_H, dat, 6);
                       // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
                       //------------------------------------------------------------------------------------------------------
             --------------
                       #define icm20602_read_registers(reg, dat, len) (soft_iic_read_8bit_registers(&icm20602_iic_struct, (reg)
             -, (dat), (len)))
               
               #endif
  275          
  276          
  277          //-------------------------------------------------------------------------------------------------------
             -------------
  278          // º¯Êý¼ò½é     ICM20602 ×Ô¼ì
  279          // ²ÎÊýËµÃ÷     void
  280          // ·µ»Ø²ÎÊý     uint8           1-×Ô¼ìÊ§°Ü 0-×Ô¼ì³É¹¦
  281          // Ê¹ÓÃÊ¾Àý     icm20602_self_check();
  282          // ±¸×¢ÐÅÏ¢     ÄÚ²¿µ÷ÓÃ
  283          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 6   

             -------------
  284          static uint8 icm20602_self_check (void)
  285          {
  286   1          uint8 dat = 0, return_state = 0;
  287   1          uint16 timeout_count = 0;
  288   1          
  289   1          while(0x12 != dat)                                                          // ÅÐ¶Ï ID ÊÇ·ñÕýÈ·
  290   1          {
  291   2              if(ICM20602_TIMEOUT_COUNT < timeout_count ++)
  292   2              {
  293   3                  return_state =  1;
  294   3                  break;
  295   3              }
  296   2              
  297   2              dat = icm20602_read_register(ICM20602_WHO_AM_I);
  298   2              system_delay_ms(10);
  299   2          }
  300   1          
  301   1          return return_state;
  302   1      }
  303          
  304          //-------------------------------------------------------------------------------------------------------
             -------------
  305          // º¯Êý¼ò½é     »ñÈ¡ ICM20602 ¼ÓËÙ¶È¼ÆÊý¾Ý
  306          // ²ÎÊýËµÃ÷     void
  307          // ·µ»Ø²ÎÊý     void
  308          // Ê¹ÓÃÊ¾Àý     icm20602_get_acc();                                             // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  309          // ±¸×¢ÐÅÏ¢
  310          //-------------------------------------------------------------------------------------------------------
             -------------
  311          void icm20602_get_acc (void)
  312          {
  313   1          uint8 dat[6];
  314   1          
  315   1          icm20602_read_registers(ICM20602_ACCEL_XOUT_H, dat, 6);
  316   1          icm20602_acc_x = (int16)(((uint16)dat[0] << 8 | dat[1]));
  317   1          icm20602_acc_y = (int16)(((uint16)dat[2] << 8 | dat[3]));
  318   1          icm20602_acc_z = (int16)(((uint16)dat[4] << 8 | dat[5]));
  319   1      }
  320          
  321          //-------------------------------------------------------------------------------------------------------
             -------------
  322          // º¯Êý¼ò½é     »ñÈ¡ICM20602ÍÓÂÝÒÇÊý¾Ý
  323          // ²ÎÊýËµÃ÷     void
  324          // ·µ»Ø²ÎÊý     void
  325          // Ê¹ÓÃÊ¾Àý     icm20602_get_gyro();                                            // Ö´ÐÐ¸Ãº¯Êýºó£¬Ö±½Ó²é¿´
             -¶ÔÓ¦µÄ±äÁ¿¼´¿É
  326          // ±¸×¢ÐÅÏ¢
  327          //-------------------------------------------------------------------------------------------------------
             -------------
  328          void icm20602_get_gyro (void)
  329          {
  330   1          uint8 dat[6];
  331   1          
  332   1          icm20602_read_registers(ICM20602_GYRO_XOUT_H, dat, 6);
  333   1          icm20602_gyro_x = (int16)(((uint16)dat[0] << 8 | dat[1]));
  334   1          icm20602_gyro_y = (int16)(((uint16)dat[2] << 8 | dat[3]));
  335   1          icm20602_gyro_z = (int16)(((uint16)dat[4] << 8 | dat[5]));
  336   1      }
  337          
  338          //-------------------------------------------------------------------------------------------------------
             -------------
  339          // º¯Êý¼ò½é     ³õÊ¼»¯ ICM20602
  340          // ²ÎÊýËµÃ÷     void
  341          // ·µ»Ø²ÎÊý     uint8           1-³õÊ¼»¯Ê§°Ü 0-³õÊ¼»¯³É¹¦
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 7   

  342          // Ê¹ÓÃÊ¾Àý     icm20602_init();
  343          // ±¸×¢ÐÅÏ¢
  344          //-------------------------------------------------------------------------------------------------------
             -------------
  345          uint8 icm20602_init (void)
  346          {
  347   1          uint8 val = 0x0, return_state = 0;
  348   1          uint16 timeout_count = 0;
  349   1          
  350   1          system_delay_ms(10);                                                        // ÉÏµçÑÓÊ±
  351   1          
  352   1      #if (ICM20602_USE_INTERFACE==HARDWARE_SPI)
                       
                       spi_init(ICM20602_SPI, SPI_MODE0, ICM20602_SPI_SPEED, ICM20602_SPC_PIN, ICM20602_SDI_PIN, ICM20602_SDO_P
             -IN, SPI_CS_NULL);
                   gpio_init(ICM20602_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);
                       
               #elif (ICM20602_USE_INTERFACE==SOFT_SPI)
  358   1              
  359   1              // Ä¬ÈÏÊ¹ÓÃË«ÏòIO£¬²»ÐèÒª³õÊ¼»¯¡£
  360   1      //      soft_spi_init(ICM20602_SPI, SPI_MODE0, 0, ICM20602_SPC_PIN, ICM20602_SDI_PIN, ICM20602_SDO_PIN, ICM206
             -02_CS_PIN);
  361   1      
  362   1      #elif (ICM20602_USE_INTERFACE==SOFT_IIC)
                       
                       soft_iic_init(&icm20602_iic_struct, ICM20602_DEV_ADDR, ICM20602_SOFT_IIC_DELAY, ICM20602_SCL_PIN, ICM206
             -02_SDA_PIN);
               
               #endif
  367   1              
  368   1          
  369   1          do
  370   1          {
  371   2              if(icm20602_self_check())
  372   2              {
  373   3                  // Èç¹û³ÌÐòÔÚÊä³öÁË¶ÏÑÔÐÅÏ¢ ²¢ÇÒÌáÊ¾³ö´íÎ»ÖÃÔÚÕâÀï
  374   3                  // ÄÇÃ´¾ÍÊÇ ICM20602 ×Ô¼ì³ö´í²¢³¬Ê±ÍË³öÁË
  375   3                  // ¼ì²éÒ»ÏÂ½ÓÏßÓÐÃ»ÓÐÎÊÌâ Èç¹ûÃ»ÎÊÌâ¿ÉÄÜ¾ÍÊÇ»µÁË
  376   3                  printf( "icm20602 self check error.\r\n");
  377   3                  return_state = 1;
  378   3                  break;
  379   3              }
  380   2              
  381   2              icm20602_write_register(ICM20602_PWR_MGMT_1, 0x80);                     // ¸´Î»Éè±¸
  382   2              system_delay_ms(2);
  383   2              
  384   2              do
  385   2              {
  386   3                  // µÈ´ý¸´Î»³É¹¦
  387   3                  val = icm20602_read_register(ICM20602_PWR_MGMT_1);
  388   3                  
  389   3                  if(ICM20602_TIMEOUT_COUNT < timeout_count ++)
  390   3                  {
  391   4                      // Èç¹û³ÌÐòÔÚÊä³öÁË¶ÏÑÔÐÅÏ¢ ²¢ÇÒÌáÊ¾³ö´íÎ»ÖÃÔÚÕâÀï
  392   4                      // ÄÇÃ´¾ÍÊÇ ICM20602 ×Ô¼ì³ö´í²¢³¬Ê±ÍË³öÁË
  393   4                      // ¼ì²éÒ»ÏÂ½ÓÏßÓÐÃ»ÓÐÎÊÌâ Èç¹ûÃ»ÎÊÌâ¿ÉÄÜ¾ÍÊÇ»µÁË
  394   4                      printf( "icm20602 reset error.\r\n");
  395   4                      return_state = 1;
  396   4                      break;
  397   4                  }
  398   3              }
  399   2              while(0x41 != val);
  400   2              
  401   2              if(1 == return_state)
  402   2              {
  403   3                  break;
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 8   

  404   3              }
  405   2              
  406   2              icm20602_write_register(ICM20602_PWR_MGMT_1,     0x01);                 // Ê±ÖÓÉèÖÃ
  407   2              icm20602_write_register(ICM20602_PWR_MGMT_2,     0x00);                 // ¿ªÆôÍÓÂÝÒÇºÍ¼ÓËÙ¶È¼Æ
  408   2              icm20602_write_register(ICM20602_CONFIG,         0x01);                 // 176HZ 1KHZ
  409   2              icm20602_write_register(ICM20602_SMPLRT_DIV,     0x07);                 // ²ÉÑùËÙÂÊ SAMPLE_RATE =
             - INTERNAL_SAMPLE_RATE / (1 + SMPLRT_DIV)
  410   2              
  411   2              // ICM20602_ACCEL_CONFIG ¼Ä´æÆ÷
  412   2              // ÉèÖÃÎª 0x00 ¼ÓËÙ¶È¼ÆÁ¿³ÌÎª ¡À2  g   »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 16384  ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý
             - µ¥Î» g(m/s^2)
  413   2              // ÉèÖÃÎª 0x08 ¼ÓËÙ¶È¼ÆÁ¿³ÌÎª ¡À4  g   »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 8192   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý
             - µ¥Î» g(m/s^2)
  414   2              // ÉèÖÃÎª 0x10 ¼ÓËÙ¶È¼ÆÁ¿³ÌÎª ¡À8  g   »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 4096   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý
             - µ¥Î» g(m/s^2)
  415   2              // ÉèÖÃÎª 0x18 ¼ÓËÙ¶È¼ÆÁ¿³ÌÎª ¡À16 g   »ñÈ¡µ½µÄ¼ÓËÙ¶È¼ÆÊý¾Ý³ýÒÔ 2048   ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý¾Ý
             - µ¥Î» g(m/s^2)
  416   2              switch(ICM20602_ACC_SAMPLE_DEFAULT)
  417   2              {
  418   3                  default:
  419   3                  {
  420   4                      printf( "ICM20602_ACC_SAMPLE_DEFAULT set error.\r\n");
  421   4                      return_state = 1;
  422   4                  }
  423   3                  break;
  424   3                  
  425   3                  case ICM20602_ACC_SAMPLE_SGN_2G:
  426   3                  {
  427   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x00);
  428   4                      icm20602_transition_factor[0] = 16384;
  429   4                  }
  430   3                  break;
  431   3                  
  432   3                  case ICM20602_ACC_SAMPLE_SGN_4G:
  433   3                  {
  434   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x08);
  435   4                      icm20602_transition_factor[0] = 8192;
  436   4                  }
  437   3                  break;
  438   3                  
  439   3                  case ICM20602_ACC_SAMPLE_SGN_8G:
  440   3                  {
  441   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x10);
  442   4                      icm20602_transition_factor[0] = 4096;
  443   4                  }
  444   3                  break;
  445   3                  
  446   3                  case ICM20602_ACC_SAMPLE_SGN_16G:
  447   3                  {
  448   4                      icm20602_write_register(ICM20602_ACCEL_CONFIG, 0x18);
  449   4                      icm20602_transition_factor[0] = 2048;
  450   4                  }
  451   3                  break;
  452   3              }
  453   2              
  454   2              if(1 == return_state)
  455   2              {
  456   3                  break;
  457   3              }
  458   2              
  459   2              // ICM20602_GYRO_CONFIG ¼Ä´æÆ÷
  460   2              // ÉèÖÃÎª 0x00 ÍÓÂÝÒÇÁ¿³ÌÎª ¡À250  dps    »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 131     ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý
             -¾Ý µ¥Î»Îª ¡ã/s
  461   2              // ÉèÖÃÎª 0x08 ÍÓÂÝÒÇÁ¿³ÌÎª ¡À500  dps    »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 65.5    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý
             -¾Ý µ¥Î»Îª ¡ã/s
  462   2              // ÉèÖÃÎª 0x10 ÍÓÂÝÒÇÁ¿³ÌÎª ¡À1000 dps    »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 32.8    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 9   

             -¾Ý µ¥Î»Îª ¡ã/s
  463   2              // ÉèÖÃÎª 0x18 ÍÓÂÝÒÇÁ¿³ÌÎª ¡À2000 dps    »ñÈ¡µ½µÄÍÓÂÝÒÇÊý¾Ý³ýÒÔ 16.4    ¿ÉÒÔ×ª»¯Îª´øÎïÀíµ¥Î»µÄÊý
             -¾Ý µ¥Î»Îª ¡ã/s
  464   2              switch(ICM20602_GYRO_SAMPLE_DEFAULT)
  465   2              {
  466   3                  default:
  467   3                  {
  468   4                      printf( "ICM20602_GYRO_SAMPLE_DEFAULT set error.\r\n");
  469   4                      return_state = 1;
  470   4                  }
  471   3                  break;
  472   3                  
  473   3                  case ICM20602_GYRO_SAMPLE_SGN_250DPS:
  474   3                  {
  475   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x00);
  476   4                      icm20602_transition_factor[1] = 131.0;
  477   4                  }
  478   3                  break;
  479   3                  
  480   3                  case ICM20602_GYRO_SAMPLE_SGN_500DPS:
  481   3                  {
  482   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x08);
  483   4                      icm20602_transition_factor[1] = 65.5;
  484   4                  }
  485   3                  break;
  486   3                  
  487   3                  case ICM20602_GYRO_SAMPLE_SGN_1000DPS:
  488   3                  {
  489   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x10);
  490   4                      icm20602_transition_factor[1] = 32.8;
  491   4                  }
  492   3                  break;
  493   3                  
  494   3                  case ICM20602_GYRO_SAMPLE_SGN_2000DPS:
  495   3                  {
  496   4                      icm20602_write_register(ICM20602_GYRO_CONFIG, 0x18);
  497   4                      icm20602_transition_factor[1] = 16.4;
  498   4                  }
  499   3                  break;
  500   3              }
  501   2              
  502   2              if(1 == return_state)
  503   2              {
  504   3                  break;
  505   3              }
  506   2              
  507   2              icm20602_write_register(ICM20602_ACCEL_CONFIG_2, 0x03);                 // Average 4 samples   44
             -.8HZ   //0x23 Average 16 samples
  508   2          }
  509   1          while(0);
  510   1          
  511   1          return return_state;
  512   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       855     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        20         17
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
C251 COMPILER V5.60.0,  zf_device_icm20602                                                 30/10/25  21:44:17  PAGE 10  

  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       191     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
