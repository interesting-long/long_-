C251 COMPILER V5.60.0,  Key                                                                19/10/25  14:22:51  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Key
OBJECT MODULE PLACED IN .\out_file\Key.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\Key.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) BROW
                    -SE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..
                    -\user;..\code) DEBUG PRINT(.\out_file\Key.lst) OBJECT(.\out_file\Key.obj) 

stmt  level    source

    1          #include "Key.h"
    2          
    3          int Press_time=0;
    4          int Trigg_time=0;
    5          unsigned char keynumber=0;
    6          unsigned char last_keynumber=0;
    7          unsigned char State=0;
    8          unsigned char Key_count=0;
    9          unsigned Time_dou=0;
   10          unsigned char Init_Flag=0;
   11          
   12          struct PageModeMap
   13          {
   14              unsigned char page_index;
   15                  unsigned char item_index;
   16                  MODE Mod;
   17          };
   18          
   19          const struct PageModeMap mode_map[] = {
   20              {0, 2, GO}, {0, 3, GO_Pararm1}, {0, 4, GO_Pararm2}, {0, 5, GO_Pararm3}, {0, 8, ADC_Show},
   21              {5, 3, TEST_SERVO}, {5, 4, Seta_Servo},
   22              {6, ANY_ITEM, TEST_PWM},  // 第6页任意项都切换到TEST_PWM
   23              {1, ANY_ITEM, GO}, {2, ANY_ITEM, GO_Pararm1}, {3, ANY_ITEM, GO_Pararm2}, {4, ANY_ITEM, GO_Pararm3}
   24          };
   25          
   26          unsigned char Key_Number(void)
   27          {
   28   1          unsigned char KeyNumber=0;
   29   1      
   30   1      //    if(gpio_get_level(IO_P26)==0){KeyNumber=1;}//下
   31   1      //    if(gpio_get_level(IO_P07)==0){KeyNumber=2;}//右
   32   1      //    if(gpio_get_level(IO_P45)==0){KeyNumber=3;}//左
   33   1      //    if(gpio_get_level(IO_P46)==0){KeyNumber=4;}//上
   34   1              
   35   1      //      if(gpio_get_level(IO_P45)==0){KeyNumber=1;}//下
   36   1      //    if(gpio_get_level(IO_P26)==0){KeyNumber=2;}//右
   37   1      //    if(gpio_get_level(IO_P46)==0){KeyNumber=3;}//左
   38   1      //    if(gpio_get_level(IO_P07)==0){KeyNumber=4;}//上
   39   1      //      if(gpio_get_level(IO_P52)==0){KeyNumber=5;}//中46,45,07
   40   1              
   41   1              
   42   1              if(gpio_get_level(IO_P26)==0){KeyNumber=1;}//下
   43   1          if(gpio_get_level(IO_P33)==0){KeyNumber=2;}//右
   44   1          if(gpio_get_level(IO_P53)==0){KeyNumber=3;}//左
   45   1          if(gpio_get_level(IO_P46)==0){KeyNumber=4;}//上
   46   1              if(gpio_get_level(IO_P07)==0){KeyNumber=5;}//中46,45,07
   47   1          return KeyNumber;
   48   1      }
   49          void Turn_mode(void)
   50          {
   51   1              int i;
   52   1          for(i = 0; i < sizeof(mode_map)/sizeof(mode_map[0]); i++) {
   53   2              // 检查页面匹配
   54   2              if((void *)Pin == (void *)&Page[mode_map[i].page_index]) {
   55   3                  // 如果是任意项匹配 或 具体项匹配
   56   3                  if(mode_map[i].item_index == ANY_ITEM || Flag == mode_map[i].item_index) {
   57   4                      CAR_Mode = (CAR_Mode == mode_map[i].Mod) ? STOP : mode_map[i].Mod;
C251 COMPILER V5.60.0,  Key                                                                19/10/25  14:22:51  PAGE 2   

   58   4                      Init_Flag = 1;
   59   4                      return;
   60   4                  }
   61   3              }
   62   2          }
   63   1      }
   64          void Key_scaner(void)
   65          {
   66   1              keynumber=Key_Number();
   67   1              switch(State)
   68   1              {
   69   2                      case State_Release:
   70   2                      {
   71   3                              if(keynumber!=0)
   72   3                              {
   73   4                                      State=State_Press_dou;
   74   4                                      Key_count=0;
   75   4                              }
   76   3                              break;
   77   3                      }
   78   2                      case State_Press_dou:
   79   2                      {
   80   3                              if(keynumber==0)
   81   3                              {
   82   4                                      State=State_Release;
   83   4                              }
   84   3                              else
   85   3                              {
   86   4                                      Key_count++;
   87   4                                      if(Key_count>=Time_dou)
   88   4                                      {
   89   5                                              State=State_Press;
   90   5                                              last_keynumber=keynumber;
   91   5      //                                      Key=keynumber;
   92   5                                      }
   93   4                              }
   94   3                              break;
   95   3                      }
   96   2                      case State_Press:
   97   2                      {
   98   3                              if(keynumber==0)
   99   3                              {
  100   4      //                              Key=last_keynumber;
  101   4                                      State=State_Release_dou;
  102   4                                      Key_count=0;
  103   4                                      Press_time=0;
  104   4                              }
  105   3                              else
  106   3                              {
  107   4                                      Press_time++;
  108   4                                      if(Press_time>Flag_press_time)
  109   4                                      {
  110   5                                              Trigg_time++;
  111   5                                              if(keynumber==5)//长按触发的操作
  112   5                                              {
  113   6                                                      Turn_mode();
  114   6                                                      Init_Flag=1;
  115   6                                                      Press_time=0;
  116   6                                                      last_keynumber=0;
  117   6                                              }
  118   5                                              else if(Trigg_time>Flag_trigg_time)
  119   5                                              {
  120   6                                                      Trigg_time=0;
  121   6                                                      Key=keynumber;
  122   6                                                      //多次触发的操作
  123   6                                              }
C251 COMPILER V5.60.0,  Key                                                                19/10/25  14:22:51  PAGE 3   

  124   5                                      }
  125   4                              }
  126   3                              break;
  127   3                      }
  128   2                      case State_Release_dou:
  129   2                      {
  130   3                              if(keynumber==0)
  131   3                              {
  132   4                                      Key_count++;
  133   4                                      if(Key_count>=Time_dou)
  134   4                                      {
  135   5                                              State=State_Release;
  136   5                                              Key=last_keynumber;  // 松开时清零
  137   5                                      }
  138   4                              }
  139   3                              else
  140   3                              {
  141   4                                      State=State_Press;
  142   4                              }
  143   3                              break;
  144   3                      }
  145   2              }
  146   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       538     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        11     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        99     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
