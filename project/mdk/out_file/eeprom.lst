C251 COMPILER V5.60.0,  eeprom                                                             06/10/25  22:25:14  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE eeprom
OBJECT MODULE PLACED IN .\out_file\eeprom.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\eeprom.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) B
                    -ROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver
                    -;..\user;..\code) DEBUG PRINT(.\out_file\eeprom.lst) OBJECT(.\out_file\eeprom.obj) 

stmt  level    source

    1          #include "eeprom.h"
    2          
    3          //-------------------------------------------------------------------------------------------------------
             -------------
    4          //  @brief      保存浮点数数组到EEPROM
    5          //  @param      void
    6          //  @return     void
    7          //-------------------------------------------------------------------------------------------------------
             -------------
    8          void eeprom_save_Num(void)
    9          {
   10   1          unsigned char temp[512] = {0};
   11   1          uint32 sector_start = SECTOR_1_ADDR;
   12   1          bit flag;
   13   1          
   14   1          // 验证数组大小
   15   1          uint32 array_size = sizeof(Num);
   16   1          if (array_size > 512) {
   17   2              return;  // 数组太大，无法存入一个扇区
   18   2          }
   19   1          
   20   1          // 保存中断状态并关闭中断
   21   1          flag = EA;
   22   1          EA = 0;
   23   1          
   24   1          // 1. 读取整个扇区到临时缓冲区
   25   1          iap_read_buff(sector_start, temp, 512);
   26   1          
   27   1          // 2. 直接将整个数组复制到缓冲区
   28   1          memcpy(temp, Num, sizeof(Num));
   29   1          
   30   1          // 3. 擦除整个扇区
   31   1          iap_erase_page(sector_start);
   32   1          system_delay_ms(10);
   33   1          
   34   1          // 4. 将修改后的数据写回扇区
   35   1          iap_write_buff(sector_start, temp, 512);
   36   1          
   37   1          // 恢复中断状态
   38   1          EA = flag;
   39   1      }
   40          
   41          //-------------------------------------------------------------------------------------------------------
             -------------
   42          //  @brief      从EEPROM读取浮点数数组
   43          //  @param      void
   44          //  @return     void
   45          //-------------------------------------------------------------------------------------------------------
             -------------
   46          void eeprom_read_Num(void)
   47          {
   48   1          unsigned char temp[512] = {0};
   49   1          uint32 sector_start = SECTOR_1_ADDR;
   50   1          bit flag;
   51   1          
   52   1          // 保存中断状态并关闭中断
   53   1          flag = EA;
C251 COMPILER V5.60.0,  eeprom                                                             06/10/25  22:25:14  PAGE 2   

   54   1          EA = 0;
   55   1          
   56   1          // 1. 读取整个扇区数据
   57   1          iap_read_buff(sector_start, temp, 512);
   58   1          
   59   1          // 2. 直接从缓冲区复制到数组
   60   1          memcpy(Num, temp, sizeof(Num));
   61   1          
   62   1          // 恢复中断状态
   63   1          EA = flag;
   64   1      }
   65          
   66          //-------------------------------------------------------------------------------------------------------
             -------------
   67          //  @brief      保存浮点数到EEPROM(自动擦除)
   68          //  @param      addr        EEPROM起始地址
   69          //  @param      value       要保存的浮点数
   70          //  @return     void
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          void eeprom_save_float(uint32 addr, float value)
   73          {
   74   1          unsigned char temp[512] = {0};
   75   1          uint32 sector_start = addr & 0xFFFFFE00;  // 获取扇区起始地址
   76   1          uint16 offset = addr & 0x1FF;             // 获取在扇区内的偏移量
   77   1          unsigned char *float_ptr = (unsigned char *)&value;
   78   1          unsigned char i;
   79   1          bit flag;
   80   1          
   81   1          // 保存中断状态并关闭中断
   82   1          flag = EA;
   83   1          EA = 0;
   84   1          
   85   1          // 1. 读取整个扇区到临时缓冲区
   86   1          iap_read_buff(sector_start, temp, 512);
   87   1          
   88   1          // 2. 修改缓冲区中的浮点数数据
   89   1          for(i = 0; i < sizeof(float); i++)
   90   1          {
   91   2              temp[offset + i] = float_ptr[i];
   92   2          }
   93   1          
   94   1          // 3. 擦除整个扇区
   95   1          iap_erase_page(sector_start);
   96   1          system_delay_ms(10);  // 等待擦除完成
   97   1          
   98   1          // 4. 将修改后的数据写回扇区
   99   1          iap_write_buff(sector_start, temp, 512);
  100   1          
  101   1          // 恢复中断状态
  102   1          EA = flag;
  103   1      }
  104          
  105          //-------------------------------------------------------------------------------------------------------
             -------------
  106          //  @brief      从EEPROM读取浮点数
  107          //  @param      addr        EEPROM起始地址
  108          //  @return     float       读取到的浮点数
  109          //-------------------------------------------------------------------------------------------------------
             -------------
  110          float eeprom_read_float(uint32 addr)
  111          {
  112   1          float value;
  113   1          unsigned char *float_ptr = (unsigned char *)&value;
  114   1          bit flag;
  115   1          
C251 COMPILER V5.60.0,  eeprom                                                             06/10/25  22:25:14  PAGE 3   

  116   1          // 保存中断状态并关闭中断
  117   1          flag = EA;
  118   1          EA = 0;
  119   1          
  120   1          // 从EEPROM按字节读取数据到浮点数变量
  121   1          iap_read_buff(addr, float_ptr, sizeof(float));
  122   1          
  123   1          // 恢复中断状态
  124   1          EA = flag;
  125   1          
  126   1          return value;
  127   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       479     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------       1550
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------          4
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1536     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
