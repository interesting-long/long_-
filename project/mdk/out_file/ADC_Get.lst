C251 COMPILER V5.60.0,  ADC_Get                                                            19/09/25  23:29:59  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ADC_Get
OBJECT MODULE PLACED IN .\out_file\ADC_Get.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\ADC_Get.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) 
                    -BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_drive
                    -r;..\user;..\code) DEBUG PRINT(.\out_file\ADC_Get.lst) OBJECT(.\out_file\ADC_Get.obj) 

stmt  level    source

    1          #include "ADC_Get.h"
    2          
    3          unsigned int raw_adc_data[4][5]={0};        // 原始数据数组
    4          unsigned int filtered_adc[4]={0};           // 滤波后的ADC值数组
    5          
    6          //电感ADC通道和定时器初始化//
    7          void ADC_GetInit(void)
    8          {   
    9   1          adc_init(ADC1_PIN,ADC_10BIT);
   10   1          adc_init(ADC2_PIN,ADC_10BIT);
   11   1          adc_init(ADC3_PIN,ADC_10BIT);
   12   1          adc_init(ADC4_PIN,ADC_10BIT);
   13   1      }
   14          
   15          //ADC采样+滤波
   16          unsigned int adc_filter(unsigned int *samples, unsigned char count)
   17          {
   18   1          unsigned char i;
   19   1          unsigned long sum = 0;
   20   1                      unsigned int max=samples[0];
   21   1                      unsigned int min=samples[0];
   22   1          
   23   1          if (count < 3) 
   24   1          {
   25   2              sum = 0;
   26   2              for (i = 0; i < count; i++) 
   27   2              {
   28   3                  sum += samples[i];
   29   3              }
   30   2              return (unsigned int)(sum / count);
   31   2          }
   32   1          
   33   1          for (i = 0; i < count; i++) 
   34   1          {
   35   2                              max=(samples[i] > max ) ? samples[i]:max;
   36   2                              min=(samples[i] < min ) ? samples[i]:min;
   37   2                              sum += samples[i];
   38   2                      }
   39   1           
   40   1          
   41   1          return (unsigned int)((sum - max - min) / (count - 2));
   42   1      }
   43          
   44          // ADC采样 和 滤波处理 函数
   45          void ADC_SampleAndFilter(void)
   46          {
   47   1          unsigned char sample_index=0;          // 采样循环计数器
   48   1          unsigned char channel_index=0;         // 通道循环计数器
   49   1          
   50   1          // 采集5次数据
   51   1          for (sample_index = 0; sample_index < 5; sample_index++) 
   52   1          {
   53   2              raw_adc_data[0][sample_index] = adc_convert(ADC1_PIN);
   54   2              raw_adc_data[1][sample_index] = adc_convert(ADC2_PIN);
   55   2              raw_adc_data[2][sample_index] = adc_convert(ADC3_PIN);
   56   2              raw_adc_data[3][sample_index] = adc_convert(ADC4_PIN);
   57   2          }
C251 COMPILER V5.60.0,  ADC_Get                                                            19/09/25  23:29:59  PAGE 2   

   58   1          
   59   1          // 滤波处理
   60   1          for (channel_index = 0; channel_index < 4; channel_index++) 
   61   1          {
   62   2              filtered_adc[channel_index] = adc_filter(raw_adc_data[channel_index], 5);
   63   2          }
   64   1              /*传递参数*/
   65   1              ADC_1 = (float)(filtered_adc[0]*1.0f);
   66   1              ADC_2 = (float)(filtered_adc[1]*1.0f);
   67   1              ADC_3 = (float)(filtered_adc[2]*1.0f);
   68   1              ADC_4 = (float)(filtered_adc[3]*1.0f);
   69   1      }
   70          
   71          
   72          //电池电压检测
   73          bit Battery_Init=0;
   74          unsigned int battery_get(void)
   75          {
   76   1          unsigned int BGV = (VREFH_ARR << 8) + VREFL_ARR;
   77   1          unsigned int battery_adc = 0;
   78   1          unsigned int ref_adc;
   79   1          unsigned int battery_v;
   80   1          unsigned char i;
   81   1          
   82   1          //通过全局变量标志位避免重复初始化
   83   1          if(Battery_Init==0)
   84   1          {
   85   2              adc_init(ADC_CH15_POWR,ADC_10BIT);
   86   2              adc_init(ADC_CH5_P15,ADC_10BIT);
   87   2              Battery_Init=1;
   88   2          }
   89   1          //采集三次取平均
   90   1          for (i = 0; i < 3; i++) 
   91   1          {
   92   2              battery_adc += adc_convert(ADC_CH5_P15);
   93   2          }
   94   1          battery_adc /= 3;                    
   95   1          
   96   1          ref_adc = adc_convert(ADC_CH15_POWR);
   97   1          
   98   1          battery_v = (unsigned int)((unsigned long)BGV * battery_adc / ref_adc);
   99   1          
  100   1          return battery_v*4;
  101   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       595     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        48          2
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        58     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
