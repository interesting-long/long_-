C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_imu660ra
OBJECT MODULE PLACED IN .\out_file\zf_device_imu660ra.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_imu660ra.c LARGE NOALIAS FLOAT64 WARN
                    -INGLEVEL(3) OPTIMIZE(3,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_de
                    -vice;..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_imu660ra.lst) OBJECT(.\out_file\zf_devi
                    -ce_imu660ra.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library å³ï¼ˆAI8051U å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æº
             -åº“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * AI8051U å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28          * é€‚ç”¨å¹³å°          AI8051U
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33          * 2024-08-01        å¤§W            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   // ç¡¬ä»¶ SPI å¼•è„š
   40          *                   SCL/SPC           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SPC_PIN å®å®šä¹‰
   41          *                   SDA/DSI           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SDI_PIN å®å®šä¹‰
   42          *                   SA0/SDO           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SDO_PIN å®å®šä¹‰
   43          *                   CS                æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_CS_PIN å®å®šä¹‰
   44          *                   VCC               3.3Vç”µæº
   45          *                   GND               ç”µæºåœ°
   46          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   47          *
   48          *                   // è½¯ä»¶ IIC å¼•è„š
   49          *                   SCL/SPC           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SCL_PIN å®å®šä¹‰
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 2   

   50          *                   SDA/DSI           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SDA_PIN å®å®šä¹‰
   51          *                   VCC               3.3Vç”µæº
   52          *                   GND               ç”µæºåœ°
   53          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   54          *                   ------------------------------------
   55          *********************************************************************************************************
             -***********/
   56          
   57          #include "zf_common_debug.h"
   58          #include "zf_driver_delay.h"
   59          #include "zf_driver_spi.h"
   60          #include "zf_driver_gpio.h"
   61          #include "zf_driver_soft_iic.h"
   62          #include "zf_device_config.h"
   63          
   64          #include "zf_device_imu660ra.h"
   65          
   66          #pragma warning disable = 183
   67          #pragma warning disable = 177
   68          
   69          int16 imu660ra_gyro_x = 0, imu660ra_gyro_y = 0, imu660ra_gyro_z = 0;            // ä¸‰è½´é™€èºä»ªæ•°æ® 
             -  gyro (é™€èºä»ª)
   70          int16 imu660ra_acc_x = 0, imu660ra_acc_y = 0, imu660ra_acc_z = 0;               // ä¸‰è½´åŠ é€Ÿåº¦è®¡æ•°æ
             -® acc  (accelerometer åŠ é€Ÿåº¦è®¡)
   71          float imu660ra_transition_factor[2] = {4096, 16.4};
   72          
   73          
   74          #if (IMU660RA_USE_INTERFACE==HARDWARE_SPI) 
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // å‡½æ•°ç®€ä»‹     IMU660RA å†™å¯„å­˜å™¨
                       // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                       // å‚æ•°è¯´æ˜     dat            æ•°æ®
                       // è¿”å›å‚æ•°     void
                       // ä½¿ç”¨ç¤ºä¾‹     imu660ra_write_register(IMU660RA_PWR_CONF, 0x00);                   // å…³é—­é«˜çº§ç
             -œç”µæ¨¡å¼
                       // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static void imu660ra_write_register(uint8 reg, uint8 dat)
                       {
                               IMU660RA_CS(0);
                               spi_write_8bit_register(IMU660RA_SPI, reg | IMU660RA_SPI_W, dat);
                               IMU660RA_CS(1);
                       }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // å‡½æ•°ç®€ä»‹     IMU660RA å†™æ•°æ®
                       // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                       // å‚æ•°è¯´æ˜     dat            æ•°æ®
                       // è¿”å›å‚æ•°     void
                       // ä½¿ç”¨ç¤ºä¾‹     imu660ra_write_registers(IMU660RA_INIT_DATA, imu660ra_config_file, sizeof(imu660ra_c
             -onfig_file));
                       // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static void imu660ra_write_registers(uint8 reg, const uint8 *dat, uint32 len)
                       {
                               IMU660RA_CS(0);
                               spi_write_8bit_registers(IMU660RA_SPI, reg | IMU660RA_SPI_W, dat, len);
                               IMU660RA_CS(1);
                       }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 3   

                       // å‡½æ•°ç®€ä»‹     IMU660RA è¯»å¯„å­˜å™¨
                       // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                       // è¿”å›å‚æ•°     uint8           æ•°æ®
                       // ä½¿ç”¨ç¤ºä¾‹     imu660ra_read_register(IMU660RA_CHIP_ID);
                       // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static uint8 imu660ra_read_register(uint8 reg)
                       {
                               uint8 dat[2];
                               IMU660RA_CS(0);
                               spi_read_8bit_registers(IMU660RA_SPI, reg | IMU660RA_SPI_R, dat, 2);
                               IMU660RA_CS(1);
                               return dat[1];
                       }
               
                       //------------------------------------------------------------------------------------------------------
             --------------
                       // å‡½æ•°ç®€ä»‹     IMU660RA è¯»æ•°æ®
                       // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
                       // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
                       // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
                       // è¿”å›å‚æ•°     void
                       // ä½¿ç”¨ç¤ºä¾‹     imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 6);
                       // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
                       //------------------------------------------------------------------------------------------------------
             --------------
                       static void imu660ra_read_registers(uint8 reg, uint8 *dat, uint32 len)
                       {
                               uint16 i = 0;
                               uint8 temp_data[8];
                               IMU660RA_CS(0);
                               spi_read_8bit_registers(IMU660RA_SPI, reg | IMU660RA_SPI_R, temp_data, len + 1);
                               IMU660RA_CS(1);
                               
                               for(i = 0; i < len; i ++)
                               {
                                       *(dat ++) = temp_data[i + 1];
                               }
                       }
               
               
               #elif (IMU660RA_USE_INTERFACE==SOFT_SPI)
  146          
  147                  #define IMU660RA_SCK(x)                         IMU660RA_SPC_PIN  = x
  148                  #define IMU660RA_MOSI(x)                        IMU660RA_SDI_PIN = x
  149                  #define IMU660RA_MISO                           IMU660RA_SDO_PIN
  150                  #define IMU660RA_CS(x)                          IMU660RA_CS_PIN  = x
  151          
  152                  //------------------------------------------------------------------------------------------------------
             --------------
  153                  //  @brief      é€šè¿‡SPIå†™ä¸€ä¸ªbyte,åŒæ—¶è¯»å–ä¸€ä¸ªbyte
  154                  //  @param      byte        å‘é€çš„æ•°æ®
  155                  //  @return     uint8 edata       return è¿”å›statusçŠ¶æ€
  156                  //  @since      v1.0
  157                  //  Sample usage:
  158                  //------------------------------------------------------------------------------------------------------
             --------------
  159                  static uint8 imu660ra_simspi_wr_byte(uint8 byte)
  160                  {
  161   1                      uint8 i;
  162   1                      for(i=0; i<8; i++)
  163   1                      {
  164   2                              IMU660RA_SCK (0);
  165   2                              IMU660RA_MOSI(byte&0x80);
  166   2                              byte <<= 1;
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 4   

  167   2                              IMU660RA_SCK (1);
  168   2                              byte |= IMU660RA_MISO;
  169   2                      }
  170   1                      IMU660RA_SCK (0);
  171   1                      return(byte);
  172   1              }
  173                  
  174                  //------------------------------------------------------------------------------------------------------
             --------------
  175                  //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€,åŒæ—¶è¿”å›statuså­—èŠ‚
  176                  //  @param      cmd         å‘½ä»¤å­—
  177                  //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
  178                  //  @since      v1.0
  179                  //  Sample usage:
  180                  //------------------------------------------------------------------------------------------------------
             --------------
  181                  static void imu660ra_simspi_w_reg_byte(uint8 cmd, uint8 val)
  182                  {
  183   1                      cmd |= IMU660RA_SPI_W;
  184   1                      imu660ra_simspi_wr_byte(cmd);
  185   1                      imu660ra_simspi_wr_byte(val);
  186   1              }
  187          
  188          
  189                  //------------------------------------------------------------------------------------------------------
             --------------
  190                  //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  191                  //  @param      cmd         å‘½ä»¤å­—
  192                  //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
  193                  //  @since      v1.0
  194                  //  Sample usage:
  195                  //------------------------------------------------------------------------------------------------------
             --------------
  196                  static void imu660ra_simspi_w_reg_bytes(uint8 cmd, uint8 *dat_addr, uint32 len)
  197                  {
  198   1                      cmd |= IMU660RA_SPI_W;
  199   1                      imu660ra_simspi_wr_byte(cmd);
  200   1                      while(len--)
  201   1                      {
  202   2                              imu660ra_simspi_wr_byte(*dat_addr++);
  203   2                      }
  204   1              }
  205          
  206                  //------------------------------------------------------------------------------------------------------
             --------------
  207                  //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  208                  //  @param      cmd         å‘½ä»¤å­—
  209                  //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  210                  //  @param      num         è¯»å–çš„æ•°é‡
  211                  //  @since      v1.0
  212                  //  Sample usage:
  213                  //------------------------------------------------------------------------------------------------------
             --------------
  214                  static void imu660ra_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  215                  {
  216   1                      cmd |= IMU660RA_SPI_R;
  217   1                      imu660ra_simspi_wr_byte(cmd);
  218   1                      while(num--)
  219   1                      {
  220   2                              *val++ = imu660ra_simspi_wr_byte(0);
  221   2                      }
  222   1              }
  223          
  224          
  225                  //------------------------------------------------------------------------------------------------------
             --------------
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 5   

  226                  // å‡½æ•°ç®€ä»‹     IMU660RA å†™å¯„å­˜å™¨
  227                  // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  228                  // å‚æ•°è¯´æ˜     dat            æ•°æ®
  229                  // è¿”å›å‚æ•°     void
  230                  // ä½¿ç”¨ç¤ºä¾‹     imu660ra_write_register(IMU660RA_PWR_CONF, 0x00);                   // å…³é—­é«˜çº§ç
             -œç”µæ¨¡å¼
  231                  // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  232                  //------------------------------------------------------------------------------------------------------
             --------------
  233                  static void imu660ra_write_register(uint8 reg, uint8 dat)
  234                  {
  235   1                      IMU660RA_CS(0);
  236   1                      imu660ra_simspi_w_reg_byte(reg | IMU660RA_SPI_W, dat);
  237   1                      IMU660RA_CS(1);
  238   1              }
  239          
  240                  //------------------------------------------------------------------------------------------------------
             --------------
  241                  // å‡½æ•°ç®€ä»‹     IMU660RA å†™æ•°æ®
  242                  // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  243                  // å‚æ•°è¯´æ˜     dat            æ•°æ®
  244                  // è¿”å›å‚æ•°     void
  245                  // ä½¿ç”¨ç¤ºä¾‹     imu660ra_write_registers(IMU660RA_INIT_dat, imu660ra_config_file, sizeof(imu660ra_co
             -nfig_file));
  246                  // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  247                  //------------------------------------------------------------------------------------------------------
             --------------
  248                  static void imu660ra_write_registers(uint8 reg, const uint8 *dat, uint32 len)
  249                  {
  250   1                      IMU660RA_CS(0);
  251   1                      imu660ra_simspi_w_reg_bytes(reg | IMU660RA_SPI_W, dat, len);
  252   1                      IMU660RA_CS(1);
  253   1              }
  254          
  255                  //------------------------------------------------------------------------------------------------------
             --------------
  256                  // å‡½æ•°ç®€ä»‹     IMU660RA è¯»å¯„å­˜å™¨
  257                  // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  258                  // è¿”å›å‚æ•°     uint8 edata           æ•°æ®
  259                  // ä½¿ç”¨ç¤ºä¾‹     imu660ra_read_register(IMU660RA_CHIP_ID);
  260                  // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  261                  //------------------------------------------------------------------------------------------------------
             --------------
  262                  static uint8 imu660ra_read_register(uint8 reg)
  263                  {
  264   1                      uint8 dat[2];
  265   1                      IMU660RA_CS(0);
  266   1                      imu660ra_simspi_r_reg_bytes(reg | IMU660RA_SPI_R, dat, 2);
  267   1                      IMU660RA_CS(1);
  268   1                      return dat[1];
  269   1              }
  270          
  271                  //------------------------------------------------------------------------------------------------------
             --------------
  272                  // å‡½æ•°ç®€ä»‹     IMU660RA è¯»æ•°æ®
  273                  // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  274                  // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
  275                  // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
  276                  // è¿”å›å‚æ•°     void
  277                  // ä½¿ç”¨ç¤ºä¾‹     imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 6);
  278                  // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  279                  //------------------------------------------------------------------------------------------------------
             --------------
  280                  static void imu660ra_read_registers(uint8 reg, uint8 *dat, uint32 len)
  281                  {
  282   1                      uint16 i = 0;
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 6   

  283   1                      uint8 temp_data[8];
  284   1                      IMU660RA_CS(0);
  285   1                      imu660ra_simspi_r_reg_bytes(reg | IMU660RA_SPI_R, temp_data, len);
  286   1                      IMU660RA_CS(1);
  287   1                      
  288   1                      for(i = 0; i < len; i ++)
  289   1                      {
  290   2                              *(dat ++) = temp_data[i + 1];
  291   2                      }
  292   1              }
  293                  
  294          #elif (IMU660RA_USE_INTERFACE==SOFT_IIC)
               
                       static soft_iic_info_struct imu660ra_iic_struct;
                       #define imu660ra_write_register(reg, dat)        (soft_iic_write_8bit_register(&imu660ra_iic_struct, (re
             -g), (dat)))
                       #define imu660ra_write_registers(reg, dat, len)  (soft_iic_write_8bit_registers(&imu660ra_iic_struct, (r
             -eg), (dat), (len)))
                       #define imu660ra_read_register(reg)               (soft_iic_read_8bit_register(&imu660ra_iic_struct, (re
             -g)))
                       #define imu660ra_read_registers(reg, dat, len)   (soft_iic_read_8bit_registers(&imu660ra_iic_struct, (re
             -g), (dat), (len)))
               
               #endif
  303          
  304          //-------------------------------------------------------------------------------------------------------
             -------------
  305          // å‡½æ•°ç®€ä»‹     IMU660RA è‡ªæ£€
  306          // å‚æ•°è¯´æ˜     void
  307          // è¿”å›å‚æ•°     uint8           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  308          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_self_check();
  309          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  310          //-------------------------------------------------------------------------------------------------------
             -------------
  311          static uint8 imu660ra_self_check (void)
  312          {
  313   1          uint8 dat = 0, return_state = 0;
  314   1          uint16 timeout_count = 0;
  315   1          
  316   1          do
  317   1          {
  318   2              if(timeout_count ++ > IMU660RA_TIMEOUT_COUNT)
  319   2              {
  320   3                  return_state =  1;
  321   3                  break;
  322   3              }
  323   2              
  324   2              dat = imu660ra_read_register(IMU660RA_CHIP_ID);
  325   2              printf("imu660ra_read_register = 0x%X\r\n", dat);
  326   2              system_delay_ms(1);
  327   2          }
  328   1          while(0x24 != dat);                                                     // è¯»å–è®¾å¤‡IDæ˜¯å¦ç­‰äº
             -0X24ï¼Œå¦‚æœä¸æ˜¯0X24åˆ™è®¤ä¸ºæ²¡æ£€æµ‹åˆ°è®¾å¤‡
  329   1          
  330   1          return return_state;
  331   1      }
  332          
  333          //-------------------------------------------------------------------------------------------------------
             -------------
  334          // å‡½æ•°ç®€ä»‹     è·å– IMU660RA åŠ é€Ÿåº¦è®¡æ•°æ®
  335          // å‚æ•°è¯´æ˜     void
  336          // è¿”å›å‚æ•°     void
  337          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_get_acc();                                             // æ‰§è¡Œè¯¥å‡½æ•°å
             -ï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  338          // å¤‡æ³¨ä¿¡æ¯     ä½¿ç”¨ SPI çš„é‡‡é›†æ—¶é—´ä¸º69us
  339          //            ä½¿ç”¨ IIC çš„é‡‡é›†æ—¶é—´ä¸º126us        é‡‡é›†åŠ é€Ÿåº¦è®¡çš„æ—¶é—´ä¸é‡‡é›†é™€èºä»ªçš„æ
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 7   

             -—¶é—´ä¸€è‡´çš„åŸå› æ˜¯éƒ½åªæ˜¯è¯»å–å¯„å­˜å™¨æ•°æ®
  340          //-------------------------------------------------------------------------------------------------------
             -------------
  341          void imu660ra_get_acc (void)
  342          {
  343   1          uint8 dat[6];
  344   1          
  345   1          imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 6);
  346   1          imu660ra_acc_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  347   1          imu660ra_acc_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  348   1          imu660ra_acc_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  349   1      }
  350          //-------------------------------------------------------------------------------------------------------
             -------------
  351          // å‡½æ•°ç®€ä»‹     è·å– IMU660RA é™€èºä»ªæ•°æ®
  352          // å‚æ•°è¯´æ˜     void
  353          // è¿”å›å‚æ•°     void
  354          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_get_gyro();                                            // æ‰§è¡Œè¯¥å‡½æ•°å
             -ï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  355          // å¤‡æ³¨ä¿¡æ¯     ä½¿ç”¨ SPI çš„é‡‡é›†æ—¶é—´ä¸º69us
  356          //            ä½¿ç”¨ IIC çš„é‡‡é›†æ—¶é—´ä¸º126us
  357          //-------------------------------------------------------------------------------------------------------
             -------------
  358          void imu660ra_get_gyro (void)
  359          {
  360   1          uint8 dat[6];
  361   1          
  362   1          imu660ra_read_registers(IMU660RA_GYRO_ADDRESS, dat, 6);
  363   1          imu660ra_gyro_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  364   1          imu660ra_gyro_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  365   1          imu660ra_gyro_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  366   1      }
  367          
  368          //-------------------------------------------------------------------------------------------------------
             -------------
  369          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– IMU660RA
  370          // å‚æ•°è¯´æ˜     void
  371          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  372          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_init();
  373          // å¤‡æ³¨ä¿¡æ¯
  374          //-------------------------------------------------------------------------------------------------------
             -------------
  375          uint8 imu660ra_init (void)
  376          {
  377   1          uint8 return_state = 0;
  378   1          system_delay_ms(20);                                                        // ç­‰å¾…è®¾å¤‡ä¸Šç”µæˆå
             -ŠŸ
  379   1          
  380   1              
  381   1      #if (IMU660RA_USE_INTERFACE==HARDWARE_SPI)   
                       spi_init(IMU660RA_SPI, SPI_MODE0, IMU660RA_SPI_SPEED, IMU660RA_SPC_PIN, IMU660RA_SDI_PIN, IMU660RA_SDO_P
             -IN, SPI_CS_NULL);   // é…ç½® IMU660RA çš„ SPI ç«¯å£
                   gpio_init(IMU660RA_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);                  // é…ç½® IMU660RA çš„CSç«¯å£
                       imu660ra_read_register(IMU660RA_CHIP_ID);                                   // è¯»å–ä¸€ä¸‹è®¾å¤‡ID å°†è
             -®¾å¤‡è®¾ç½®ä¸ºSPIæ¨¡å¼
               #elif (IMU660RA_USE_INTERFACE==SOFT_SPI)
  386   1              // é»˜è®¤ä½¿ç”¨åŒå‘IOï¼Œä¸éœ€è¦åˆå§‹åŒ–ã€‚
  387   1              // soft_spi_init (IMU660RA_SPI, SPI_MODE0, 0, IMU660RA_SPC_PIN, IMU660RA_SDI_PIN, IMU660RA_SDO_PIN, IMU6
             -60RA_CS_PIN);
  388   1          imu660ra_read_register(IMU660RA_CHIP_ID);                                                   // è¯»å–ä¸€ä¸‹è®¾å¤‡ID å°†è®¾å¤‡è®¾ç½®ä¸ºSP
             -Iæ¨¡å¼
  389   1      #elif (IMU660RA_USE_INTERFACE==SOFT_IIC)
                       soft_iic_init(&imu660ra_iic_struct, IMU660RA_DEV_ADDR, IMU660RA_SOFT_IIC_DELAY, IMU660RA_SCL_PIN, IMU660
             -RA_SDA_PIN);        // é…ç½® IMU660RA çš„ IIC ç«¯å£
               #endif
  392   1      
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 8   

  393   1          
  394   1          do
  395   1          {
  396   2              if(imu660ra_self_check())                                               // IMU660RA è‡ªæ£€
  397   2              {
  398   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  399   3                  // é‚£ä¹ˆå°±æ˜¯ IMU660RA è‡ªæ£€å‡ºé”™å¹¶è¶…æ—¶é€€å‡ºäº†
  400   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  401   3                  printf( "imu660ra self check error.\r\n");
  402   3                  return_state = 1;
  403   3                  break;
  404   3              }
  405   2              
  406   2              imu660ra_write_register(IMU660RA_PWR_CONF, 0x00);                       // å…³é—­é«˜çº§çœç”µæ¨¡å
             -¼
  407   2              system_delay_ms(1);
  408   2              imu660ra_write_register(IMU660RA_INIT_CTRL, 0x00);                      // å¼€å§‹å¯¹æ¨¡å—è¿›è¡Œå
             -ˆå§‹åŒ–é…ç½®
  409   2              imu660ra_write_registers(IMU660RA_INIT_DATA, imu660ra_config_file, sizeof(imu660ra_config_file));
             -   // è¾“å‡ºé…ç½®æ–‡ä»¶
  410   2              imu660ra_write_register(IMU660RA_INIT_CTRL, 0x01);                      // åˆå§‹åŒ–é…ç½®ç»“æŸ
  411   2              system_delay_ms(20);
  412   2              
  413   2              if(1 != imu660ra_read_register(IMU660RA_INT_STA))                       // æ£€æŸ¥æ˜¯å¦é…ç½®å®Œæ
             -ˆ
  414   2              {
  415   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  416   3                  // é‚£ä¹ˆå°±æ˜¯ IMU660RA é…ç½®åˆå§‹åŒ–æ–‡ä»¶å‡ºé”™äº†
  417   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  418   3                  printf( "imu660ra init error.\r\n");
  419   3                  return_state = 1;
  420   3                  break;
  421   3              }
  422   2              
  423   2              imu660ra_write_register(IMU660RA_PWR_CTRL, 0x0E);                       // å¼€å¯æ€§èƒ½æ¨¡å¼  ä½
             -¿èƒ½é™€èºä»ªã€åŠ é€Ÿåº¦ã€æ¸©åº¦ä¼ æ„Ÿå™¨
  424   2              imu660ra_write_register(IMU660RA_ACC_CONF, 0xA7);                       // åŠ é€Ÿåº¦é‡‡é›†é…ç½® 
             -æ€§èƒ½æ¨¡å¼ æ­£å¸¸é‡‡é›† 50Hz  é‡‡æ ·é¢‘ç‡
  425   2              imu660ra_write_register(IMU660RA_GYR_CONF, 0xA9);                       // é™€èºä»ªé‡‡é›†é…ç½® 
             -æ€§èƒ½æ¨¡å¼ æ­£å¸¸é‡‡é›† 200Hz é‡‡æ ·é¢‘ç‡
  426   2              
  427   2              // IMU660RA_ACC_SAMPLE å¯„å­˜å™¨
  428   2              // è®¾ç½®ä¸º 0x00 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±2  g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 16384  å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  429   2              // è®¾ç½®ä¸º 0x01 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±4  g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 8192   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  430   2              // è®¾ç½®ä¸º 0x02 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±8  g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 4096   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  431   2              // è®¾ç½®ä¸º 0x03 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º Â±16 g   è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 2048   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  432   2              switch(IMU660RA_ACC_SAMPLE_DEFAULT)
  433   2              {
  434   3                  default:
  435   3                  {
  436   4                      printf( "IMU660RA_ACC_SAMPLE_DEFAULT set error.\r\n");
  437   4                      return_state = 1;
  438   4                  }
  439   3                  break;
  440   3                  
  441   3                  case IMU660RA_ACC_SAMPLE_SGN_2G:
  442   3                  {
  443   4                      imu660ra_write_register(IMU660RA_ACC_RANGE, 0x00);
  444   4                      imu660ra_transition_factor[0] = 16384;
  445   4                  }
  446   3                  break;
  447   3                  
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 9   

  448   3                  case IMU660RA_ACC_SAMPLE_SGN_4G:
  449   3                  {
  450   4                      imu660ra_write_register(IMU660RA_ACC_RANGE, 0x01);
  451   4                      imu660ra_transition_factor[0] = 8192;
  452   4                  }
  453   3                  break;
  454   3                  
  455   3                  case IMU660RA_ACC_SAMPLE_SGN_8G:
  456   3                  {
  457   4                      imu660ra_write_register(IMU660RA_ACC_RANGE, 0x02);
  458   4                      imu660ra_transition_factor[0] = 4096;
  459   4                  }
  460   3                  break;
  461   3                  
  462   3                  case IMU660RA_ACC_SAMPLE_SGN_16G:
  463   3                  {
  464   4                      imu660ra_write_register(IMU660RA_ACC_RANGE, 0x03);
  465   4                      imu660ra_transition_factor[0] = 2048;
  466   4                  }
  467   3                  break;
  468   3              }
  469   2              
  470   2              if(1 == return_state)
  471   2              {
  472   3                  break;
  473   3              }
  474   2              
  475   2              // IMU660RA_GYR_RANGE å¯„å­˜å™¨
  476   2              // è®¾ç½®ä¸º 0x04 é™€èºä»ªé‡ç¨‹ä¸º Â±125  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 262.4   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  477   2              // è®¾ç½®ä¸º 0x03 é™€èºä»ªé‡ç¨‹ä¸º Â±250  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 131.2   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  478   2              // è®¾ç½®ä¸º 0x02 é™€èºä»ªé‡ç¨‹ä¸º Â±500  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 65.6    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  479   2              // è®¾ç½®ä¸º 0x01 é™€èºä»ªé‡ç¨‹ä¸º Â±1000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 32.8    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  480   2              // è®¾ç½®ä¸º 0x00 é™€èºä»ªé‡ç¨‹ä¸º Â±2000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 16.4    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  481   2              switch(IMU660RA_GYRO_SAMPLE_DEFAULT)
  482   2              {
  483   3                  default:
  484   3                  {
  485   4                      printf( "IMU660RA_GYRO_SAMPLE_DEFAULT set error.\r\n");
  486   4                      return_state = 1;
  487   4                  }
  488   3                  break;
  489   3                  
  490   3                  case IMU660RA_GYRO_SAMPLE_SGN_125DPS:
  491   3                  {
  492   4                      imu660ra_write_register(IMU660RA_GYR_RANGE, 0x04);
  493   4                      imu660ra_transition_factor[1] = 262.4;
  494   4                  }
  495   3                  break;
  496   3                  
  497   3                  case IMU660RA_GYRO_SAMPLE_SGN_250DPS:
  498   3                  {
  499   4                      imu660ra_write_register(IMU660RA_GYR_RANGE, 0x03);
  500   4                      imu660ra_transition_factor[1] = 131.2;
  501   4                  }
  502   3                  break;
  503   3                  
  504   3                  case IMU660RA_GYRO_SAMPLE_SGN_500DPS:
  505   3                  {
  506   4                      imu660ra_write_register(IMU660RA_GYR_RANGE, 0x02);
  507   4                      imu660ra_transition_factor[1] = 65.6;
  508   4                  }
C251 COMPILER V5.60.0,  zf_device_imu660ra                                                 01/11/25  21:30:17  PAGE 10  

  509   3                  break;
  510   3                  
  511   3                  case IMU660RA_GYRO_SAMPLE_SGN_1000DPS:
  512   3                  {
  513   4                      imu660ra_write_register(IMU660RA_GYR_RANGE, 0x01);
  514   4                      imu660ra_transition_factor[1] = 32.8;
  515   4                  }
  516   3                  break;
  517   3                  
  518   3                  case IMU660RA_GYRO_SAMPLE_SGN_2000DPS:
  519   3                  {
  520   4                      imu660ra_write_register(IMU660RA_GYR_RANGE, 0x00);
  521   4                      imu660ra_transition_factor[1] = 16.4;
  522   4                  }
  523   3                  break;
  524   3              }
  525   2              
  526   2              if(1 == return_state)
  527   2              {
  528   3                  break;
  529   3              }
  530   2          }
  531   1          while(0);
  532   1          
  533   1          return return_state;
  534   1      }
  535          
  536          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1068     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        20         36
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       222     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
