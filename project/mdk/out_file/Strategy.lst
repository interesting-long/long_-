C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Strategy
OBJECT MODULE PLACED IN .\out_file\Strategy.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\Strategy.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE)
                    - BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driv
                    -er;..\user;..\code) DEBUG PRINT(.\out_file\Strategy.lst) OBJECT(.\out_file\Strategy.obj) 

stmt  level    source

    1          #include "Strategy.h"
    2          unsigned int if_time=0;
    3          unsigned int if2_time=0;
    4          unsigned int Continue_Time=0;
    5          unsigned char Enter_Flag_Left=0;
    6          unsigned char Cycle_Stat=EXIT;
    7          
    8          unsigned char Road_Stat=Short_Str;
    9          
   10          unsigned int Short_Time=0;
   11          unsigned int Long_Time=0;
   12          unsigned int Bend_Time=0;
   13          unsigned int SLOW_Time=0;
   14          unsigned int Accel_Time=0;
   15          
   16          unsigned int Entern_Flag_Time=0;
   17          unsigned int Entern_Delay_Time=0;
   18          unsigned int Entern_Continue_Time=0;
   19          int turn_Value=0;
   20          int Mode_Flag=0;
   21          
   22          
   23          //环岛判断
   24          void if_Cycle(void)
   25          {
   26   1              switch(Cycle_Stat)
   27   1              {
   28   2                      case EXIT:
   29   2                      {
   30   3                              
   31   3                              if(ADC_2==1023 || ADC_3==1023 )
   32   3                              {
   33   4                                      if_time++;
   34   4                                      if(if_time>Entern_Flag_Time)
   35   4                                      {
   36   5                                              Cycle_Stat=APPROACH;
   37   5                                              if_time=0;
   38   5                                      }
   39   4                              }
   40   3                              else
   41   3                              {
   42   4                                      if_time=0;
   43   4                              }
   44   3                              break;
   45   3                      }
   46   2                      case APPROACH:
   47   2                      {
   48   3                                      if2_time++;
   49   3                                      if(if2_time>Entern_Delay_Time)
   50   3                                      {
   51   4                                              Cycle_Stat=Left_ENTER;
   52   4                                              if2_time=0;
   53   4                                      }
   54   3                              break;
   55   3                      }
   56   2                      case Left_ENTER:
   57   2                      {
C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 2   

   58   3                              Enter_Flag_Left=1;
   59   3                              Buzzer_ON();
   60   3                              Continue_Time++;
   61   3                              if(Continue_Time>Entern_Continue_Time)
   62   3                              {
   63   4                                      Cycle_Stat=EXIT;
   64   4                                      Continue_Time = 0;  //
   65   4                      Enter_Flag_Left = 0;     //
   66   4                                      Buzzer_OFF();
   67   4                              }
   68   3                              break;
   69   3                      }
   70   2                      default :
   71   2                      {
   72   3                              CAR_STOP();
   73   3                              break;
   74   3                      }
   75   2              }
   76   1      
   77   1      }
   78          //切弯补丁
   79          int Help_turn()
   80          {
   81   1              int left  = ADC_1 + ADC_2;
   82   1              int right = ADC_3 + ADC_4;
   83   1              if (left < 200 && right < 200)
   84   1              {
   85   2                      // 同时满足，取较小一侧优先
   86   2                      if (left < right)
   87   2                              return -50;   // 左
   88   2                      else
   89   2                              return 50;    // 右
   90   2              }
   91   1              else if (left < 200)
   92   1              {
   93   2                      return -50;   // 左
   94   2              }
   95   1              else if (right < 200)
   96   1              {
   97   2                      return 50;    // 右
   98   2              }
   99   1              else
  100   1              {
  101   2                      return 0;     // 不转
  102   2              }
  103   1      }
  104          void Help_turn2(int* temp, int value, int ADC_Flag)
  105          {
  106   1          static int last_dir = 0;    // -1 左，+1 右，0 未定
  107   1          static int first_double = 1; // 是否是第一次进入“双小”状态
  108   1      
  109   1          int left  = ADC_1 + ADC_2;
  110   1          int right = ADC_3 + ADC_4;
  111   1          const int delta = 15;  // 左右接近的最小差值门限
  112   1      
  113   1          if (left < ADC_Flag && right < ADC_Flag)
  114   1          {
  115   2              if (first_double) // ★第一次双小
  116   2              {
  117   3                  if (left < right)
  118   3                  {
  119   4                      *temp = -value;   // 左
  120   4                      last_dir = -1;
  121   4                  }
  122   3                  else
  123   3                  {
C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 3   

  124   4                      *temp = value;    // 右
  125   4                      last_dir = 1;
  126   4                  }
  127   3                  first_double = 0; // 标记已经处理过第一次
  128   3              }
  129   2              else // ★后续双小
  130   2              {
  131   3                  if (abs(left - right) < delta)
  132   3                  {
  133   4                      // 按照上次方向走
  134   4                      if (last_dir == -1) *temp = -value;
  135   4                      else if (last_dir == 1) *temp = value;
  136   4                      else *temp = value; // 默认
  137   4                  }
  138   3                  else if (left < right)
  139   3                  {
  140   4                      *temp = -value;
  141   4                      last_dir = -1;
  142   4                  }
  143   3                  else
  144   3                  {
  145   4                      *temp = value;
  146   4                      last_dir = 1;
  147   4                  }
  148   3              }
  149   2          }
  150   1          else if (left < ADC_Flag)
  151   1          {
  152   2              *temp = -value;
  153   2              last_dir = -1;
  154   2              first_double = 1; // 重置，下次再遇到“双小”时重新走第一次逻辑
  155   2          }
  156   1          else if (right < ADC_Flag)
  157   1          {
  158   2              *temp = value;
  159   2              last_dir = 1;
  160   2              first_double = 1; // 同上
  161   2          }
  162   1      }
  163          
  164          void Help_turn3(int* temp, int value, int value2,int ADC_Flag ,int ADC_Flag2)
  165          {
  166   1              //value2>value1,ADC_Flag1>ADC_Flag2
  167   1          static int last_dir = 0;    // -1 左，+1 右，0 未定
  168   1          static int first_double = 1; // 是否是第一次进入“双小”状态
  169   1          int left  = ADC_1 + ADC_2;
  170   1          int right = ADC_3 + ADC_4;
  171   1              float K = (float)(value2 - value) / (ADC_Flag - ADC_Flag2);
  172   1          const int delta = 15;  // 左右接近的最小差值门限
  173   1      
  174   1          if (left < ADC_Flag && right < ADC_Flag)
  175   1          {
  176   2                      if (left < ADC_Flag2 && right < ADC_Flag2)
  177   2                      {
  178   3                              if (first_double) // ★第一次双小
  179   3                              {
  180   4                                      if (left < right)
  181   4                                      {
  182   5                                              *temp = -value2;   // 左
  183   5                                              last_dir = -1;
  184   5                                      }
  185   4                                      else
  186   4                                      {
  187   5                                              *temp = value2;    // 右
  188   5                                              last_dir = 1;
  189   5                                      }
C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 4   

  190   4                                      first_double = 0; // 标记已经处理过第一次
  191   4                              }
  192   3                              else // ★后续双小
  193   3                              {
  194   4                                      if (abs(left - right) < delta)
  195   4                                      {
  196   5                                              // 按照上次方向走
  197   5                                              if (last_dir == -1) *temp = -value2;
  198   5                                              else if (last_dir == 1) *temp = value2;
  199   5                                              else *temp = value2; // 默认
  200   5                                                  // 向左转
  201   5            // 向右转
  202   5                                      }
  203   4                                      else if (left < right)
  204   4                                      {
  205   5                                              *temp = -value2;
  206   5                                              last_dir = -1;
  207   5                                      }
  208   4                                      else
  209   4                                      {
  210   5                                              *temp = value2;
  211   5                                              last_dir = 1;
  212   5                                      }
  213   4                              }
  214   3                      }
  215   2                      else if(left < ADC_Flag2)
  216   2                      {
  217   3                              *temp = -value2;
  218   3                              last_dir = -1;
  219   3                              first_double = 1; 
  220   3                      }
  221   2                      else if(right < ADC_Flag2)
  222   2                      {
  223   3                              *temp = value2;
  224   3                              last_dir = 1;
  225   3                              first_double = 1; // 同上
  226   3                      }
  227   2                      else
  228   2                      {
  229   3                              if (abs(left - right) < delta)
  230   3                              {
  231   4                                      // 按照上次方向走
  232   4                                      if (last_dir == -1) *temp = -value;
  233   4                                      else if (last_dir == 1) *temp = value;
  234   4                                      else *temp = value; 
  235   4                              }
  236   3      //                      else if (left < right)
  237   3      //                      {
  238   3      //                              *temp = -(value + (ADC_Flag - left) * K);
  239   3      //                              last_dir = -1;
  240   3      //                              first_double = 1; 
  241   3      //                      }
  242   3      //                      else
  243   3      //                      {
  244   3      //                              *temp = value + (ADC_Flag - right) * K;
  245   3      //                              last_dir = 1;
  246   3      //                              first_double = 1; 
  247   3      //                      }
  248   3                      }
  249   2          }
  250   1          else if (left < ADC_Flag)
  251   1          {
  252   2              *temp = -(value + (ADC_Flag - left) * K);
  253   2                      last_dir = -1;
  254   2                      first_double = 1; 
  255   2          }
C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 5   

  256   1          else if (right < ADC_Flag)
  257   1          {
  258   2                      *temp = value + (ADC_Flag - right) * K;
  259   2                      last_dir = 1;
  260   2                      first_double = 1; 
  261   2          }
  262   1      }
  263          
  264          int Help_turn_Two(int temp, int value, int value2, int ADC_Flag, int ADC_Flag2)
  265          {
  266   1          int left  = ADC_1 + ADC_2;
  267   1          int right = ADC_3 + ADC_4;
  268   1      
  269   1          // -------- 第一组阈值判断 --------
  270   1          if (left < ADC_Flag && right < ADC_Flag)
  271   1          {
  272   2              return (left < right) ? (Servo_Mide - value) : (Servo_Mide + value);
  273   2          }
  274   1          else if (left < ADC_Flag)
  275   1          {
  276   2              return Servo_Mide - value;
  277   2          }
  278   1          else if (right < ADC_Flag)
  279   1          {
  280   2              return Servo_Mide + value;
  281   2          }
  282   1      
  283   1          // -------- 第二组阈值判断 --------
  284   1          if (left < ADC_Flag2 && right < ADC_Flag2)
  285   1          {
  286   2              return (left < right) ? (Servo_Mide - value2) : (Servo_Mide + value2);
  287   2          }
  288   1          else if (left < ADC_Flag2)
  289   1          {
  290   2              return Servo_Mide - value2;
  291   2          }
  292   1          else if (right < ADC_Flag2)
  293   1          {
  294   2              return Servo_Mide + value2;
  295   2          }
  296   1      
  297   1          // -------- 都不满足，返回原值 --------
  298   1          return temp;
  299   1      }
  300          
  301          int State_of_road(void)
  302          {
  303   1              switch(Road_Stat)
  304   1              {
  305   2                      case Short_Str:
  306   2                      {
  307   3                              Motor_Update_Smooth(Short_add);
  308   3                              if(abs(dajiao)<Stright_Flag_Value)
  309   3                              {
  310   4                                      Long_Time++;
  311   4                                      Bend_Time=0;
  312   4                                      if(Long_Time>Long_Judge_Time)
  313   4                                      {
  314   5                                              Long_Time=0;
  315   5                                              Road_Stat=Long_Str;
  316   5                                      }
  317   4                              }
  318   3                              else
  319   3                              {
  320   4                                      Long_Time=0;
  321   4                                      Bend_Time++;
C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 6   

  322   4                                      {
  323   5                                              if(Bend_Time>Bend_Judge_Time)
  324   5                                              {
  325   6                                                      Bend_Time=0;
  326   6                                                      Road_Stat=Short_Bend;
  327   6                                              }
  328   5                                      }
  329   4                              }
  330   3                              return Short_add;
  331   3                              break;
  332   3                      }
  333   2                      case Long_Str:
  334   2                      {
  335   3                              Motor_Update_Smooth(Long_add);
  336   3                              Accel_Time++;
  337   3                              if(abs(dajiao)>Bend_Flag_Value)
  338   3                              {
  339   4                                      Bend_Time++;
  340   4                                      if(Bend_Time>Bend_Judge_Time)
  341   4                                      {
  342   5                                              if(Accel_Time>180)//加速时间1.5s
  343   5                                              {
  344   6                                                      Road_Stat=Long_Bend;
  345   6                                                      SLOW_Time = 0;
  346   6                                              }
  347   5                                              else
  348   5                                              {
  349   6                                                      Road_Stat=Short_Bend;
  350   6                                              }
  351   5                                              Bend_Time=0;
  352   5                                              Accel_Time=0;
  353   5                                      }
  354   4                              }
  355   3                              else
  356   3                              {
  357   4                                      Bend_Time=0;
  358   4                              }
  359   3                              return Long_add;
  360   3                              break;
  361   3                      }
  362   2                      case Short_Bend:
  363   2                      {
  364   3                              Motor_Update_Smooth(Bend_speed);
  365   3                              if(abs(dajiao)>Bend_Flag_Value)
  366   3                              {
  367   4                                      Short_Time=0;
  368   4                              }
  369   3                              else
  370   3                              {
  371   4                                      Short_Time++;
  372   4                                      if(Short_Time>Short_Judge_Time)
  373   4                                      {
  374   5                                              Short_Time=0;
  375   5                                              Road_Stat=Short_Str;
  376   5                                      }
  377   4                              }
  378   3                              return Bend_speed;
  379   3                              break;
  380   3                      }
  381   2                      case Long_Bend:
  382   2                      {
  383   3                              SLOW_Time++;
  384   3                              if(SLOW_Time>L_Turn_B_Slow_Time)
  385   3                              {
  386   4                                      Buzzer_OFF();
  387   4                                      Motor_Update_Smooth(Bend_speed);//弯道速度
C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 7   

  388   4                              }
  389   3                              else
  390   3                              {
  391   4                                      Buzzer_ON();
  392   4                                      
  393   4                                      Motor_Update_Smooth(L_Turn_B_Slow_Value);//减速
  394   4                              }
  395   3                              //检查是否回到了直道
  396   3                              if(abs(dajiao)<Bend_Flag_Value)
  397   3                              {
  398   4                                      Short_Time++;
  399   4                                      if(Short_Time>Short_Judge_Time)
  400   4                                      {
  401   5                                              Buzzer_OFF();
  402   5                                              Short_Time=0;
  403   5                                              SLOW_Time=0;
  404   5                                              Road_Stat=Short_Str;
  405   5                                      }
  406   4                                      
  407   4                              }
  408   3                              else
  409   3                              {
  410   4                                      Short_Time=0;
  411   4                              }
  412   3                              if(SLOW_Time>L_Turn_B_Slow_Time)
  413   3                              {
  414   4                                      return Bend_speed;
  415   4                              }
  416   3                              else
  417   3                              {
  418   4                                      return L_Turn_B_Slow_Value;
  419   4                              }
  420   3                              
  421   3                              break;
  422   3                      }
  423   2                      default :
  424   2                      {
  425   3                              CAR_STOP();
  426   3                              return 0;
  427   3                              break;
  428   3                      }
  429   2              
  430   2              }
  431   1      }
  432          
  433          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2106     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        37          6
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       137     ------
End of Module Information.

C251 COMPILER V5.60.0,  Strategy                                                           19/10/25  14:42:06  PAGE 8   


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
