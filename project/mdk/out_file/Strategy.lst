C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Strategy
OBJECT MODULE PLACED IN .\out_file\Strategy.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\Strategy.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE)
                    - BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driv
                    -er;..\user;..\code) DEBUG PRINT(.\out_file\Strategy.lst) OBJECT(.\out_file\Strategy.obj) 

stmt  level    source

    1          #include "Strategy.h"
    2          
    3          unsigned char Protect_Flag_Cycle=1;
    4          
    5          /**********环岛的参数******************/
    6          unsigned char Cycle_Stat=EXIT;
    7          
    8          unsigned int Wait_Time = 0;
    9          unsigned int if_time=0;
   10          unsigned int if2_time=0;
   11          unsigned int Continue_Time=0;
   12          
   13          unsigned int Entern_Flag_Time=0;
   14          unsigned int Entern_Delay_Time=0;
   15          unsigned int Entern_Continue_Time=0;
   16          int turn_Value=0;
   17          int Mode_Flag=0;
   18          
   19          unsigned char Enter_Flag_Left=0;
   20          /**********速测的参数******************/
   21                  /**无惯性导航**/
   22          unsigned char Road_Stat=Stright;
   23          unsigned int Short_Time=0;
   24          unsigned int Long_Time=0;
   25          unsigned int Bend_Time=0;
   26          //unsigned int SLOW_Time=0;
   27          unsigned int Accel_Time=0;
   28          
   29          unsigned char Normal_Slow_Flag=0;
   30          /***************有惯性导航**********/
   31                                  /*******记录函数的数据******/
   32          #define Delta_Angle_Flag        0.3
   33          #define Turn_Mode_Time          7
   34          #define Short_Stright_Flag  4000
   35          #define Long_Stright_Flag  8000
   36          #define dajiao_Value 200
   37          long int all_road=0;
   38          float delta_angle=0;
   39          float angle=0;
   40          unsigned char Max_Item=0;
   41          unsigned char Guan_Dao_Show_Item=0;
   42          
   43          int Straightaways_Time=0;
   44          int Turnways_Time=0;
   45          long int Short_road_Data[30]={0};
   46          long int Long_road_Data[30]={0};
   47          long int Long_short_Data[30]={0};
   48          long int Turn_road_Data[30]={0};
   49          long int All_road_Data[100]={0};
   50          float All_angle_Data[100]={0};
   51          unsigned char All_road_Flag[100]={0};
   52          
   53          int Now_Item=0;
   54          int Str_Data_Buffer=0;
   55          float angle_buffer=0;
   56          road_Data Now_State_Road=Stright;
   57          unsigned char Last_State_Road=Stright;
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 2   

   58                                  /*******速测函数的数据*******/
   59          #define Data_Error  600
   60          #define ACC_Buffer  300
   61          //#define forword_Error  300
   62          #define Angle_Error  15
   63          #define Short_ACC_Value  3
   64          #define Long_ACC_Value  4
   65          #define Slow_Value -3
   66          unsigned char Guan_Slow_Flag;
   67          int Guan_Slow_Time;
   68          unsigned char Acclerate_Flag=0;
   69          
   70          //环岛判断
   71          void if_Cycle(void)
   72          {
   73   1              if(Wait_Time>0)
   74   1              {
   75   2                      Wait_Time--;
   76   2                      return;
   77   2              }
   78   1              else
   79   1              {
   80   2                      switch(Cycle_Stat)
   81   2                      {
   82   3                              case EXIT:
   83   3                              {
   84   4                                      
   85   4                                      if(ADC_2==1023 || ADC_3==1023 )
   86   4                                      {
   87   5                                              if_time++;
   88   5                                              if(if_time>Entern_Flag_Time)
   89   5                                              {
   90   6                                                      Cycle_Stat=APPROACH;
   91   6                                                      Protect_Flag_Cycle=0;
   92   6                                                      if_time=0;
   93   6                                              }
   94   5                                      }
   95   4                                      else
   96   4                                      {
   97   5                                              if_time=0;
   98   5                                      }
   99   4                                      break;
  100   4                              }
  101   3                              case APPROACH:
  102   3                              {
  103   4                                              if2_time++;
  104   4                                              if(if2_time>Entern_Delay_Time)
  105   4                                              {
  106   5                                                      Cycle_Stat=Left_ENTER;
  107   5                                                      if2_time=0;
  108   5                                              }
  109   4                                      break;
  110   4                              }
  111   3                              case Left_ENTER:
  112   3                              {
  113   4                                      Enter_Flag_Left=1;
  114   4                                      Buzzer_ON();
  115   4                                      Continue_Time++;
  116   4      //                              angle+=imu963ra_gyro_y/100;
  117   4                                      if(Continue_Time>Entern_Continue_Time)//abs(angle)>Turn_Angle*10
  118   4                                      {
  119   5                                              Cycle_Stat=EXIT;
  120   5                                              Buzzer_OFF();
  121   5                                              Protect_Flag_Cycle=1;
  122   5                                              Wait_Time = 200;
  123   5                                              Continue_Time = 0;  //
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 3   

  124   5                                              Enter_Flag_Left = 0;     //
  125   5                                      }
  126   4                                      break;
  127   4                              }
  128   3                              default :
  129   3                              {
  130   4                                      CAR_STOP();
  131   4                                      break;
  132   4                              }
  133   3                      }
  134   2              }
  135   1      
  136   1      }
  137          //切弯补丁
  138          int Help_turn()
  139          {
  140   1              int left  = ADC_1 + ADC_2;
  141   1              int right = ADC_3 + ADC_4;
  142   1              if (left < 200 && right < 200)
  143   1              {
  144   2                      // 同时满足，取较小一侧优先
  145   2                      if (left < right)
  146   2                              return -50;   // 左
  147   2                      else
  148   2                              return 50;    // 右
  149   2              }
  150   1              else if (left < 200)
  151   1              {
  152   2                      return -50;   // 左
  153   2              }
  154   1              else if (right < 200)
  155   1              {
  156   2                      return 50;    // 右
  157   2              }
  158   1              else
  159   1              {
  160   2                      return 0;     // 不转
  161   2              }
  162   1      }
  163          void Help_turn2(int temp, int value, int ADC_Flag)
  164          {
  165   1          static int last_dir = 0;    // -1 左，+1 右，0 未定
  166   1          static int first_double = 1; // 是否是第一次进入“双小”状态
  167   1      
  168   1          int left  = ADC_1 + ADC_2;
  169   1          int right = ADC_3 + ADC_4;
  170   1              int target=0;
  171   1              
  172   1              static float smooth_temp = 0;
  173   1          const int delta = 30;  // 左右接近的最小差值门限
  174   1              const float smooth=0.3;
  175   1              
  176   1              static float vel = 0;
  177   1              float kp=0.3;
  178   1              float kd=0.5;
  179   1              float error=0;
  180   1              if(left < ADC_Flag || right < ADC_Flag)
  181   1              {
  182   2                      if (left < ADC_Flag && right < ADC_Flag)
  183   2                      {
  184   3                              if (first_double) // ★第一次双小
  185   3                              {
  186   4                                      if (left < right)
  187   4                                      {
  188   5                                              target = -value;   // 左
  189   5                                              last_dir = -1;
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 4   

  190   5                                      }
  191   4                                      else
  192   4                                      {
  193   5                                              target = value;    // 右
  194   5                                              last_dir = 1;
  195   5                                      }
  196   4                                      first_double = 0; // 标记已经处理过第一次
  197   4                              }
  198   3                              else // ★后续双小
  199   3                              {
  200   4                                      if (abs(left - right) < delta)
  201   4                                      {
  202   5                                              // 按照上次方向走
  203   5                                              if (last_dir == -1) target = -value;
  204   5                                              else if (last_dir == 1) target = value;
  205   5                                              else target = value; // 默认
  206   5                                      }
  207   4                                      else if (left < right)
  208   4                                      {
  209   5                                              target = -value;
  210   5                                              last_dir = -1;
  211   5                                      }
  212   4                                      else
  213   4                                      {
  214   5                                              target = value;
  215   5                                              last_dir = 1;
  216   5                                      }
  217   4                              }
  218   3                      }
  219   2                      else if (left < ADC_Flag)
  220   2                      {
  221   3                              target = -value;
  222   3                              last_dir = -1;
  223   3      //                      first_double = 1; // 重置，下次再遇到“双小”时重新走第一次逻辑
  224   3                      }
  225   2                      else
  226   2                      {
  227   3                              target = value;
  228   3                              last_dir = 1;
  229   3      //                      first_double = 1; // 同上
  230   3                      }
  231   2                      error = target-smooth_temp;
  232   2                      vel = vel + kp * error - kd * vel;
  233   2                      smooth_temp = smooth_temp + vel;
  234   2                      pwm_set_duty(Servo_Pwm,Servo_Mide+smooth_temp);
  235   2              }
  236   1              else 
  237   1              {
  238   2                      first_double = 1;
  239   2                      error = temp-smooth_temp;
  240   2                      vel = vel + kp * error - kd * vel;
  241   2                      smooth_temp = smooth_temp + vel;
  242   2                      if(abs(smooth_temp-temp)<300)
  243   2                      {
  244   3                              pwm_set_duty(Servo_Pwm,Servo_Mide+(temp+smooth_temp)/2);
  245   3                      }
  246   2                      else
  247   2                      {
  248   3      //                      smooth_temp = smooth_temp * (1 - smooth) + temp * smooth;
  249   3                              pwm_set_duty(Servo_Pwm,Servo_Mide+smooth_temp);
  250   3                      }
  251   2              }
  252   1      }
  253          
  254          void Help_turn3(int* temp, int value, int value2,int ADC_Flag ,int ADC_Flag2)
  255          {
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 5   

  256   1              //value2>value1,ADC_Flag1>ADC_Flag2
  257   1          static int last_dir = 0;    // -1 左，+1 右，0 未定
  258   1          static int first_double = 1; // 是否是第一次进入“双小”状态
  259   1          int left  = ADC_1 + ADC_2;
  260   1          int right = ADC_3 + ADC_4;
  261   1              float K = (float)(value2 - value) / (ADC_Flag - ADC_Flag2);
  262   1          const int delta = 30;  // 左右接近的最小差值门限
  263   1      
  264   1          if (left < ADC_Flag && right < ADC_Flag)
  265   1          {
  266   2                      if (left < ADC_Flag2 && right < ADC_Flag2)
  267   2                      {
  268   3                              if (first_double) // ★第一次双小
  269   3                              {
  270   4                                      if (left < right)
  271   4                                      {
  272   5                                              *temp = -value2;   // 左
  273   5                                              last_dir = -1;
  274   5                                      }
  275   4                                      else
  276   4                                      {
  277   5                                              *temp = value2;    // 右
  278   5                                              last_dir = 1;
  279   5                                      }
  280   4                                      first_double = 0; // 标记已经处理过第一次
  281   4                              }
  282   3                              else // ★后续双小
  283   3                              {
  284   4                                      if (abs(left - right) < delta)
  285   4                                      {
  286   5                                              // 按照上次方向走
  287   5                                              if (last_dir == -1) *temp = -value2;
  288   5                                              else if (last_dir == 1) *temp = value2;
  289   5                                              else *temp = value2; // 默认
  290   5                                                  // 向左转
  291   5            // 向右转
  292   5                                      }
  293   4                                      else if (left < right)
  294   4                                      {
  295   5                                              *temp = -value2;
  296   5                                              last_dir = -1;
  297   5                                      }
  298   4                                      else
  299   4                                      {
  300   5                                              *temp = value2;
  301   5                                              last_dir = 1;
  302   5                                      }
  303   4                              }
  304   3                      }
  305   2                      else if(left < ADC_Flag2)
  306   2                      {
  307   3                              *temp = -value2;
  308   3                              last_dir = -1;
  309   3                              first_double = 1; 
  310   3                      }
  311   2                      else if(right < ADC_Flag2)
  312   2                      {
  313   3                              *temp = value2;
  314   3                              last_dir = 1;
  315   3                              first_double = 1; // 同上
  316   3                      }
  317   2                      else
  318   2                      {
  319   3                              if (abs(left - right) < delta)
  320   3                              {
  321   4                                      // 按照上次方向走
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 6   

  322   4                                      if (last_dir == -1) *temp = -value;
  323   4                                      else if (last_dir == 1) *temp = value;
  324   4                                      else *temp = value; 
  325   4                              }
  326   3      //                      else if (left < right)
  327   3      //                      {
  328   3      //                              *temp = -(value + (ADC_Flag - left) * K);
  329   3      //                              last_dir = -1;
  330   3      //                              first_double = 1; 
  331   3      //                      }
  332   3      //                      else
  333   3      //                      {
  334   3      //                              *temp = value + (ADC_Flag - right) * K;
  335   3      //                              last_dir = 1;
  336   3      //                              first_double = 1; 
  337   3      //                      }
  338   3                      }
  339   2          }
  340   1          else if (left < ADC_Flag)
  341   1          {
  342   2              *temp = -(value + (ADC_Flag - left) * K);
  343   2                      last_dir = -1;
  344   2                      first_double = 1; 
  345   2          }
  346   1          else if (right < ADC_Flag)
  347   1          {
  348   2                      *temp = value + (ADC_Flag - right) * K;
  349   2                      last_dir = 1;
  350   2                      first_double = 1; 
  351   2          }
  352   1      }
  353          
  354          int Help_turn_Two(int temp, int value, int value2, int ADC_Flag, int ADC_Flag2)
  355          {
  356   1          int left  = ADC_1 + ADC_2;
  357   1          int right = ADC_3 + ADC_4;
  358   1      
  359   1          // -------- 第一组阈值判断 --------
  360   1          if (left < ADC_Flag && right < ADC_Flag)
  361   1          {
  362   2              return (left < right) ? (Servo_Mide - value) : (Servo_Mide + value);
  363   2          }
  364   1          else if (left < ADC_Flag)
  365   1          {
  366   2              return Servo_Mide - value;
  367   2          }
  368   1          else if (right < ADC_Flag)
  369   1          {
  370   2              return Servo_Mide + value;
  371   2          }
  372   1      
  373   1          // -------- 第二组阈值判断 --------
  374   1          if (left < ADC_Flag2 && right < ADC_Flag2)
  375   1          {
  376   2              return (left < right) ? (Servo_Mide - value2) : (Servo_Mide + value2);
  377   2          }
  378   1          else if (left < ADC_Flag2)
  379   1          {
  380   2              return Servo_Mide - value2;
  381   2          }
  382   1          else if (right < ADC_Flag2)
  383   1          {
  384   2              return Servo_Mide + value2;
  385   2          }
  386   1      
  387   1          // -------- 都不满足，返回原值 --------
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 7   

  388   1          return temp;
  389   1      }
  390          /*
  391          
  392          */
  393          void State_of_road(void)
  394          {
  395   1              switch(Road_Stat)
  396   1              {
  397   2                      case Short_Str:
  398   2                      {
  399   3                              Motor_Update_Smooth(Short_add);
  400   3                              if(abs(dajiao)<Stright_Flag_Value)
  401   3                              {
  402   4                                      Long_Time++;
  403   4                                      Bend_Time=0;
  404   4                                      if(Long_Time>Long_Judge_Time)
  405   4                                      {
  406   5                                              Long_Time=0;
  407   5                                              Road_Stat=Long_Str;
  408   5                                      }
  409   4                              }
  410   3                              else
  411   3                              {
  412   4                                      Long_Time=0;
  413   4                                      Bend_Time++;
  414   4                                      {
  415   5                                              if(Bend_Time>Bend_Judge_Time)
  416   5                                              {
  417   6                                                      Normal_Slow_Flag=1;
  418   6                                                      Bend_Time=0;
  419   6                                                      Road_Stat=Short_Bend;
  420   6                                              }
  421   5                                      }
  422   4                              }
  423   3                              break;
  424   3                      }
  425   2                      case Long_Str:
  426   2                      {
  427   3                              Motor_Update_Smooth(Long_add);
  428   3                              Accel_Time++;
  429   3                              if(abs(dajiao)>Bend_Flag_Value)
  430   3                              {
  431   4                                      Bend_Time++;
  432   4                                      if(Bend_Time>Bend_Judge_Time)
  433   4                                      {
  434   5                                              if(Accel_Time>150)//加速时间1.5s
  435   5                                              {
  436   6                                                      Road_Stat=Long_Bend;
  437   6                                                      Normal_Slow_Flag=1;
  438   6                                              }
  439   5                                              else
  440   5                                              {
  441   6                                                      Road_Stat=Short_Bend;
  442   6                                              }
  443   5                                              Bend_Time=0;
  444   5                                              Accel_Time=0;
  445   5                                      }
  446   4                              }
  447   3                              else
  448   3                              {
  449   4                                      Bend_Time=0;
  450   4                              }
  451   3                              break;
  452   3                      }
  453   2                      case Short_Bend:
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 8   

  454   2                      {
  455   3                              if(Normal_Slow_Flag)
  456   3                              {
  457   4                                      Buzzer_ON();
  458   4                                      Motor_Update_Smooth(L_Turn_B_Slow_Value);//减速
  459   4                                      if((encoder_data_dir_1+encoder_data_dir_2)/2<(Left_Speed+Right_Speed)/2*100)
  460   4                                      {
  461   5                                              Normal_Slow_Flag=0;
  462   5                                      }
  463   4                              }
  464   3                              else
  465   3                              {
  466   4                                      Buzzer_OFF();
  467   4                                      Motor_Update_Smooth(Bend_speed);//弯道速度
  468   4                                      
  469   4                              }       
  470   3                              if(abs(dajiao)>Bend_Flag_Value)
  471   3                              {
  472   4                                      Short_Time=0;
  473   4                              }
  474   3                              else
  475   3                              {
  476   4                                      Short_Time++;
  477   4                                      if(Short_Time>Short_Judge_Time)
  478   4                                      {
  479   5                                              Short_Time=0;
  480   5                                              Road_Stat=Short_Str;
  481   5                                      }
  482   4                              }
  483   3                              break;
  484   3                      }
  485   2                      case Long_Bend:
  486   2                      {
  487   3                              if(Normal_Slow_Flag)
  488   3                              {
  489   4                                      Buzzer_ON();
  490   4                                      Motor_Update(L_Turn_B_Slow_Value);//减速
  491   4                                      if((encoder_data_dir_1+encoder_data_dir_2)/2<(Left_Speed+Right_Speed)/2*100-100)
  492   4                                      {
  493   5                                              Normal_Slow_Flag=0;
  494   5                                      }
  495   4                              }
  496   3                              else
  497   3                              {
  498   4                                      Buzzer_OFF();
  499   4                                      Motor_Update_Smooth(Bend_speed);//弯道速度
  500   4                                      
  501   4                              }                       
  502   3                              //检查是否回到了直道
  503   3                              if(abs(dajiao)<Bend_Flag_Value)
  504   3                              {
  505   4                                      Short_Time++;
  506   4                                      if(Short_Time>Short_Judge_Time)
  507   4                                      {
  508   5                                              Buzzer_OFF();
  509   5                                              Short_Time=0;
  510   5                                              Road_Stat=Short_Str;
  511   5                                      }
  512   4                              }
  513   3                              else
  514   3                              {
  515   4                                      Short_Time=0;
  516   4                              }
  517   3                              
  518   3                              break;
  519   3                      }
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 9   

  520   2                      default :
  521   2                      {
  522   3                              CAR_STOP();
  523   3                              break;
  524   3                      }
  525   2              
  526   2              }
  527   1      }
  528          
  529          void Inertial_Navigation(int value)//记录赛道
  530          {
  531   1              all_road+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;//得到直道的路程
  532   1              
  533   1              switch(Now_State_Road)
  534   1              {
  535   2                      case Turn_Ways:
  536   2                      {
  537   3                              if(abs(dajiao)<value && abs(delta_angle)<Delta_Angle_Flag)
  538   3                              {
  539   4                                      Straightaways_Time++;
  540   4                                      if(Straightaways_Time>Turn_Mode_Time)
  541   4                                      {
  542   5                                              Now_State_Road=Stright;
  543   5                                              Straightaways_Time=0;
  544   5                                      }
  545   4                              }
  546   3                              else
  547   3                              {
  548   4                                      Straightaways_Time=0;
  549   4                              }
  550   3                              break;
  551   3                      }
  552   2                      case Stright:
  553   2                      {
  554   3                              Str_Data_Buffer+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;
  555   3                              if(abs(dajiao)>value || abs(delta_angle)>Delta_Angle_Flag)
  556   3                              {
  557   4                                      Turnways_Time++;
  558   4                                      if(Turnways_Time>Turn_Mode_Time)
  559   4                                      {
  560   5                                              Now_State_Road=Turn_Ways;
  561   5                                              Turnways_Time=0;
  562   5                                              /****/
  563   5                                      }
  564   4                              }
  565   3                              else
  566   3                              {
  567   4                                      angle_Get();
  568   4                                      Turnways_Time=0;
  569   4                              }
  570   3                              break;
  571   3                      }
  572   2      
  573   2              }
  574   1              /**************状态切换*********************/
  575   1              if(Last_State_Road!=Now_State_Road)
  576   1              {
  577   2                      if(Last_State_Road == Stright)
  578   2                      {
  579   3                              if(Str_Data_Buffer>Long_Stright_Flag)
  580   3                              {
  581   4                                      Long_road_Data[Now_Item]=Str_Data_Buffer;
  582   4                                      Long_short_Data[Now_Item]=Str_Data_Buffer;
  583   4                                      All_road_Data[Now_Item]=all_road-Str_Data_Buffer;//开始加速的里程
  584   4                                      All_angle_Data[Now_Item]=angle_buffer;
  585   4                                      All_road_Flag[Now_Item]=2;
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 10  

  586   4                                      printf("L_ZHI,all_road:%ld,angle:%f,Long_road_Data:%d,Start:%d,Now_Item:%d\n",all_road,angle_buffer,S
             -tr_Data_Buffer,all_road-Str_Data_Buffer,Now_Item);
  587   4                                      Str_Data_Buffer=0;
  588   4                                      angle_buffer=0;
  589   4                                      Now_Item++;
  590   4                                      
  591   4                              }
  592   3                              else if(Str_Data_Buffer>Short_Stright_Flag)
  593   3                              {
  594   4                                      Short_road_Data[Now_Item]=Str_Data_Buffer;
  595   4                                      Long_short_Data[Now_Item]=Str_Data_Buffer;
  596   4                                      All_road_Data[Now_Item]=all_road-Str_Data_Buffer;//开始加速的里程
  597   4                                      All_angle_Data[Now_Item]=angle_buffer;
  598   4                                      All_road_Flag[Now_Item]=1;
  599   4                                      printf("ZHI,all_road:%ld,angle:%f,Short_road_Data:%d,Start:%d,Now_Item:%d\n",all_road,angle_buffer,St
             -r_Data_Buffer,all_road-Str_Data_Buffer,Now_Item);
  600   4                                      Str_Data_Buffer=0;
  601   4                                      angle_buffer=0;
  602   4                                      Now_Item++;
  603   4                              }
  604   3                              else
  605   3                              {
  606   4                                      printf("None\n");
  607   4                                      Str_Data_Buffer=0;
  608   4                                      angle_buffer=0;
  609   4                                      
  610   4                              }
  611   3                      }
  612   2                      Last_State_Road=Now_State_Road;
  613   2                      if(Max_Item<Now_Item)
  614   2                      {
  615   3                              Max_Item=Now_Item;
  616   3                      }
  617   2              }
  618   1      
  619   1      }
  620          /*
  621          半惯导的速策
  622          */
  623          void Half_State_of_road(int value)
  624          {
  625   1              all_road+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;//得到直道的路程
  626   1              if(Acclerate_Flag==1)
  627   1              {
  628   2                      Str_Data_Buffer+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;
  629   2                      if(Str_Data_Buffer<Short_road_Data[Now_Item]-ACC_Buffer)
  630   2                      {
  631   3                              Buzzer_ON();//短直道加速
  632   3                              Motor_Update_Smooth(Short_ACC_Value);
  633   3                      }
  634   2                      else
  635   2                      {
  636   3                              Acclerate_Flag=0;
  637   3                              Str_Data_Buffer=0;
  638   3                              Buzzer_OFF();
  639   3                              Now_Item++;
  640   3                              printf("normal_S\n");
  641   3                      }
  642   2                      return;
  643   2              }
  644   1              else if(Acclerate_Flag==2)
  645   1              {
  646   2                      Str_Data_Buffer+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;
  647   2                      if(Str_Data_Buffer<Long_road_Data[Now_Item]-ACC_Buffer)
  648   2                      {
  649   3                              Buzzer_ON();//chang直道加速
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 11  

  650   3                              Motor_Update_Smooth(Long_ACC_Value);
  651   3                      }
  652   2                      else
  653   2                      {
  654   3                              Acclerate_Flag=0;
  655   3                              Str_Data_Buffer=0;
  656   3                              
  657   3                              Guan_Slow_Flag=1;
  658   3                              
  659   3                              Buzzer_OFF();
  660   3                              Now_Item++;
  661   3                              printf("normal_L\n");
  662   3                      }
  663   2                      return;
  664   2              }
  665   1              else
  666   1              {
  667   2                      if(Guan_Slow_Flag )
  668   2                      {
  669   3                              Buzzer_ON();
  670   3                              Motor_Update_Smooth(-10);
  671   3                              if((encoder_data_dir_1 + encoder_data_dir_2)/2<(Left_Speed+Right_Speed)/2*100)
  672   3                              {
  673   4                                      Guan_Slow_Flag=0;
  674   4                              }
  675   3                      }
  676   2                      else
  677   2                      {
  678   3                              Buzzer_OFF();
  679   3                              Speed_Control();
  680   3                      }
  681   2              }
  682   1      
  683   1              if(all_road-All_road_Data[Now_Item]>-Data_Error && all_road-All_road_Data[Now_Item]<Long_short_Data[Now_
             -Item]-Data_Error)
  684   1              {
  685   2                      Str_Data_Buffer+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;
  686   2                      if(All_road_Flag[Now_Item]==1 && abs(angle-All_angle_Data[Now_Item])<=Angle_Error && abs(dajiao)<dajiao
             -_Value)//短直道
  687   2                      {
  688   3                              Acclerate_Flag=1;
  689   3      //                      printf("ACC_Short!Recode:%ld,Now:%ld.\n",All_road_Data[Now_Item],all_road);
  690   3                              
  691   3                      }
  692   2                      else if(All_road_Flag[Now_Item]==2 && abs(angle-All_angle_Data[Now_Item])<=Angle_Error && abs(dajiao)<d
             -ajiao_Value)
  693   2                      {
  694   3                              Acclerate_Flag=2;
  695   3      //                      printf("ACC_Long!Recode:%ld,Now:%ld.\n",All_road_Data[Now_Item],all_road);
  696   3                      }
  697   2              }
  698   1              else if(all_road-All_road_Data[Now_Item]-Long_short_Data[Now_Item]>=0 && All_road_Data[Now_Item+1]!=0)
  699   1              {
  700   2                      Now_Item++;
  701   2                      printf("Worn\n");
  702   2                      Str_Data_Buffer=0;
  703   2      //              printf("all_road:%ld,All_road_Data:%ld\n",all_road,All_road_Data[Now_Item]);
  704   2              }
  705   1      }
*** WARNING C47 IN LINE 623 OF ..\code\Strategy.c: 'value': unreferenced parameter
  706          void angle_Get(void)
  707          {
  708   1              if(angle_buffer==0)
  709   1              {
  710   2                      angle_buffer=angle;
  711   2              }
C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 12  

  712   1              else 
  713   1              {
  714   2                      angle_buffer+=angle;
  715   2                      angle_buffer/=2;
  716   2              }
  717   1      }
  718          //              case Long_Stright:
  719          //              {
  720          //                      Str_Data_Buffer+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;
  721          //                      if(abs(dajiao)>value && delta_angle>Delta_Angle_Flag)
  722          //                      {
  723          //                              Turnways_Time++;
  724          //                              if(Turnways_Time>Turn_Mode_Time)
  725          //                              {
  726          //                                      Now_State_Road=Turn_Ways;
  727          //                                      Turnways_Time=0;
  728          //                                      /****/
  729          //                              }
  730          //                      }
  731          //                      else
  732          //                      {
  733          //                              Turnways_Time=0;
  734          //                      }
  735          //                      break;
  736          //              }
  737          //              case Short_Stright:
  738          //              {
  739          //                      Str_Data_Buffer+=(encoder_data_dir_1 + encoder_data_dir_2) / 20;
  740          //                      if(abs(dajiao)>value && delta_angle>Delta_Angle_Flag)
  741          //                      {
  742          //                              Turnways_Time++;
  743          //                              if(Turnways_Time>Turn_Mode_Time)
  744          //                              {
  745          //                                      Now_State_Road=Turn_Ways;
  746          //                                      
  747          //                                      Turnways_Time=0;
  748          //                                      /****/
  749          //                              }
  750          //                      }
  751          //                      else if(Str_Data_Buffer>Long_Stright_Flag)
  752          //                      {
  753          //                              Now_State_Road=Long_Stright;
  754          //                              angle_buffer=angle;
  755          //                      }
  756          //                      break;
  757          //              }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5267     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      1460         18
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1844     ------
End of Module Information.

C251 COMPILER V5.60.0,  Strategy                                                           08/11/25  20:28:26  PAGE 13  


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
