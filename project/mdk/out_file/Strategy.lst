C251 COMPILER V5.60.0,  Strategy                                                           15/10/25  21:40:19  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Strategy
OBJECT MODULE PLACED IN .\out_file\Strategy.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\Strategy.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE)
                    - BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driv
                    -er;..\user;..\code) DEBUG PRINT(.\out_file\Strategy.lst) OBJECT(.\out_file\Strategy.obj) 

stmt  level    source

    1          #include "Strategy.h"
    2          unsigned int if_time=0;
    3          unsigned int if2_time=0;
    4          unsigned int Continue_Time=0;
    5          unsigned char Enter_Flag_Left=0;
    6          unsigned char Cycle_Stat=EXIT;
    7          
    8          unsigned char Road_Stat=Short_Str;
    9          
   10          unsigned int Short_Time=0;
   11          unsigned int Long_Time=0;
   12          unsigned int Bend_Time=0;
   13          unsigned int SLOW_Time=0;
   14          unsigned int Accel_Time=0;
   15          
   16          unsigned int Entern_Flag_Time=0;
   17          unsigned int Entern_Delay_Time=0;
   18          unsigned int Entern_Continue_Time=0;
   19          int turn_Value=0;
   20          int Mode_Flag=0;
   21          
   22          
   23          //环岛判断
   24          void if_Cycle(void)
   25          {
   26   1              switch(Cycle_Stat)
   27   1              {
   28   2                      case EXIT:
   29   2                      {
   30   3                              
   31   3                              if(ADC_2==1023 || ADC_3==1023 )
   32   3                              {
   33   4                                      if_time++;
   34   4                                      if(if_time>Entern_Flag_Time)
   35   4                                      {
   36   5                                              Cycle_Stat=APPROACH;
   37   5                                              if_time=0;
   38   5                                      }
   39   4                              }
   40   3                              else
   41   3                              {
   42   4                                      if_time=0;
   43   4                              }
   44   3                              break;
   45   3                      }
   46   2                      case APPROACH:
   47   2                      {
   48   3                                      if2_time++;
   49   3                                      if(if2_time>Entern_Delay_Time)
   50   3                                      {
   51   4                                              Cycle_Stat=Left_ENTER;
   52   4                                              if2_time=0;
   53   4                                      }
   54   3                              break;
   55   3                      }
   56   2                      case Left_ENTER:
   57   2                      {
C251 COMPILER V5.60.0,  Strategy                                                           15/10/25  21:40:19  PAGE 2   

   58   3                              Enter_Flag_Left=1;
   59   3                              Buzzer_ON();
   60   3                              Continue_Time++;
   61   3                              if(Continue_Time>Entern_Continue_Time)
   62   3                              {
   63   4                                      Cycle_Stat=EXIT;
   64   4                                      Continue_Time = 0;  //
   65   4                      Enter_Flag_Left = 0;     //
   66   4                                      Buzzer_OFF();
   67   4                              }
   68   3                              break;
   69   3                      }
   70   2                      default :
   71   2                      {
   72   3                              CAR_STOP();
   73   3                              break;
   74   3                      }
   75   2              }
   76   1      
   77   1      }
   78          //切弯补丁
   79          int Help_turn()
   80          {
   81   1              int left  = ADC_1 + ADC_2;
   82   1              int right = ADC_3 + ADC_4;
   83   1              if (left < 200 && right < 200)
   84   1              {
   85   2                      // 同时满足，取较小一侧优先
   86   2                      if (left < right)
   87   2                              return -50;   // 左
   88   2                      else
   89   2                              return 50;    // 右
   90   2              }
   91   1              else if (left < 200)
   92   1              {
   93   2                      return -50;   // 左
   94   2              }
   95   1              else if (right < 200)
   96   1              {
   97   2                      return 50;    // 右
   98   2              }
   99   1              else
  100   1              {
  101   2                      return 0;     // 不转
  102   2              }
  103   1      }
  104          void Help_turn2(int* temp, int value, int ADC_Flag)
  105          {
  106   1          static int count_left = 0;   // 记录左侧条件满足的次数
  107   1          static int count_right = 0;  // 记录右侧条件满足的次数
  108   1          static int last_direction = 0;  // 上次的方向：0表示未确定，1表示左，2表示右
  109   1          int left  = ADC_1 + ADC_2;
  110   1          int right = ADC_3 + ADC_4;
  111   1      
  112   1          // 设定一个阈值，当满足条件次数达到该值时才改变方向
  113   1          const int threshold = 70;
  114   1      
  115   1          if (left < ADC_Flag && right < ADC_Flag)
  116   1          {
  117   2              // 第一次判断时立即执行
  118   2              if (last_direction == 0)
  119   2              {
  120   3                  // 第一次转向时立即执行
  121   3                  if (left < right)
  122   3                  {
  123   4                      *temp = -value;   // 左
C251 COMPILER V5.60.0,  Strategy                                                           15/10/25  21:40:19  PAGE 3   

  124   4                      last_direction = 1;  // 更新方向为左
  125   4                  }
  126   3                  else
  127   3                  {
  128   4                      *temp = value;    // 右
  129   4                      last_direction = 2;  // 更新方向为右
  130   4                  }
  131   3              }
  132   2              else
  133   2              {
  134   3                  // 判断是否发生了方向变化
  135   3                  if (last_direction == 1 && left < right)
  136   3                  {
  137   4                      // 由左转右，开始计次
  138   4                      count_right++;
  139   4                      count_left = 0;  // 清除左侧计数
  140   4                      if (count_right >= threshold)
  141   4                      {
  142   5                          *temp = value;  // 右
  143   5                          last_direction = 2;  // 更新方向为右
  144   5                          count_right = 0;  // 重置计数器
  145   5                      }
  146   4                  }
  147   3                  else if (last_direction == 2 && left > right)
  148   3                  {
  149   4                      // 由右转左，开始计次
  150   4                      count_left++;
  151   4                      count_right = 0;  // 清除右侧计数
  152   4                      if (count_left >= threshold)
  153   4                      {
  154   5                          *temp = -value;  // 左
  155   5                          last_direction = 1;  // 更新方向为左
  156   5                          count_left = 0;  // 重置计数器
  157   5                      }
  158   4                  }
  159   3              }
  160   2          }
  161   1          else if (left < ADC_Flag)
  162   1          {
  163   2              // 不需要计次，立即执行左转
  164   2              *temp = -value;   // 左
  165   2              last_direction = 1;  // 更新方向为左
  166   2              count_left = 0;    // 清除计数器
  167   2          }
  168   1          else if (right < ADC_Flag)
  169   1          {
  170   2              // 不需要计次，立即执行右转
  171   2              *temp = value;    // 右
  172   2              last_direction = 2;  // 更新方向为右
  173   2              count_right = 0;   // 清除计数器
  174   2          }
  175   1      }
  176          
  177          int Help_turn_Two(int temp, int value, int value2, int ADC_Flag, int ADC_Flag2)
  178          {
  179   1          int left  = ADC_1 + ADC_2;
  180   1          int right = ADC_3 + ADC_4;
  181   1      
  182   1          // -------- 第一组阈值判断 --------
  183   1          if (left < ADC_Flag && right < ADC_Flag)
  184   1          {
  185   2              return (left < right) ? (Servo_Mide - value) : (Servo_Mide + value);
  186   2          }
  187   1          else if (left < ADC_Flag)
  188   1          {
  189   2              return Servo_Mide - value;
C251 COMPILER V5.60.0,  Strategy                                                           15/10/25  21:40:19  PAGE 4   

  190   2          }
  191   1          else if (right < ADC_Flag)
  192   1          {
  193   2              return Servo_Mide + value;
  194   2          }
  195   1      
  196   1          // -------- 第二组阈值判断 --------
  197   1          if (left < ADC_Flag2 && right < ADC_Flag2)
  198   1          {
  199   2              return (left < right) ? (Servo_Mide - value2) : (Servo_Mide + value2);
  200   2          }
  201   1          else if (left < ADC_Flag2)
  202   1          {
  203   2              return Servo_Mide - value2;
  204   2          }
  205   1          else if (right < ADC_Flag2)
  206   1          {
  207   2              return Servo_Mide + value2;
  208   2          }
  209   1      
  210   1          // -------- 都不满足，返回原值 --------
  211   1          return temp;
  212   1      }
  213          
  214          int State_of_road(void)
  215          {
  216   1              switch(Road_Stat)
  217   1              {
  218   2                      case Short_Str:
  219   2                      {
  220   3                              Motor_Update(Short_add);
  221   3                              if(abs(dajiao)<Stright_Flag_Value)
  222   3                              {
  223   4                                      Long_Time++;
  224   4                                      Bend_Time=0;
  225   4                                      if(Long_Time>Long_Judge_Time)
  226   4                                      {
  227   5                                              Long_Time=0;
  228   5                                              Road_Stat=Long_Str;
  229   5                                      }
  230   4                              }
  231   3                              else
  232   3                              {
  233   4                                      Long_Time=0;
  234   4                                      Bend_Time++;
  235   4                                      {
  236   5                                              if(Bend_Time>Bend_Judge_Time)
  237   5                                              {
  238   6                                                      Bend_Time=0;
  239   6                                                      Road_Stat=Short_Bend;
  240   6                                              }
  241   5                                      }
  242   4                              }
  243   3                              return Short_add;
  244   3                              break;
  245   3                      }
  246   2                      case Long_Str:
  247   2                      {
  248   3                              Motor_Update(Long_add);
  249   3                              Accel_Time++;
  250   3                              if(abs(dajiao)>Bend_Flag_Value)
  251   3                              {
  252   4                                      Bend_Time++;
  253   4                                      if(Bend_Time>Bend_Judge_Time)
  254   4                                      {
  255   5                                              if(Accel_Time>200)//加速时间1.5s
C251 COMPILER V5.60.0,  Strategy                                                           15/10/25  21:40:19  PAGE 5   

  256   5                                              {
  257   6                                                      Road_Stat=Long_Bend;
  258   6                                              }
  259   5                                              else
  260   5                                              {
  261   6                                                      Road_Stat=Short_Bend;
  262   6                                              }
  263   5                                              Bend_Time=0;
  264   5                                              Accel_Time=0;
  265   5                                      }
  266   4                              }
  267   3                              else
  268   3                              {
  269   4                                      Bend_Time=0;
  270   4                              }
  271   3                              return Long_add;
  272   3                              break;
  273   3                      }
  274   2                      case Short_Bend:
  275   2                      {
  276   3                              Motor_Update(Bend_speed);
  277   3                              if(abs(dajiao)>Bend_Flag_Value)
  278   3                              {
  279   4                                      Short_Time=0;
  280   4                              }
  281   3                              else
  282   3                              {
  283   4                                      Short_Time++;
  284   4                                      if(Short_Time>Short_Judge_Time)
  285   4                                      {
  286   5                                              Short_Time=0;
  287   5                                              Road_Stat=Short_Str;
  288   5                                      }
  289   4                              }
  290   3                              return Bend_speed;
  291   3                              break;
  292   3                      }
  293   2                      case Long_Bend:
  294   2                      {
  295   3                              SLOW_Time++;
  296   3                              if(SLOW_Time>L_Turn_B_Slow_Time)
  297   3                              {
  298   4                                      Buzzer_OFF();
  299   4                                      Motor_Update(Bend_speed);//弯道速度
  300   4                              }
  301   3                              else
  302   3                              {
  303   4                                      Buzzer_ON();
  304   4                                      
  305   4                                      Motor_Update(L_Turn_B_Slow_Value);//减速
  306   4                              }
  307   3                              //检查是否回到了直道
  308   3                              if(abs(dajiao)<Bend_Flag_Value)
  309   3                              {
  310   4                                      Short_Time++;
  311   4                                      if(Short_Time>Short_Judge_Time)
  312   4                                      {
  313   5                                              Buzzer_OFF();
  314   5                                              Short_Time=0;
  315   5                                              SLOW_Time=0;
  316   5                                              Road_Stat=Short_Str;
  317   5                                      }
  318   4                                      
  319   4                              }
  320   3                              else
  321   3                              {
C251 COMPILER V5.60.0,  Strategy                                                           15/10/25  21:40:19  PAGE 6   

  322   4                                      Short_Time=0;
  323   4                              }
  324   3                              if(SLOW_Time>L_Turn_B_Slow_Time)
  325   3                              {
  326   4                                      return Bend_speed;
  327   4                              }
  328   3                              else
  329   3                              {
  330   4                                      return L_Turn_B_Slow_Value;
  331   4                              }
  332   3                              
  333   3                              break;
  334   3                      }
  335   2                      default :
  336   2                      {
  337   3                              CAR_STOP();
  338   3                              return 0;
  339   3                              break;
  340   3                      }
  341   2              
  342   2              }
  343   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1574     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        35          2
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       130     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
