C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Strategy
OBJECT MODULE PLACED IN .\out_file\Strategy.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\Strategy.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE)
                    - BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driv
                    -er;..\user;..\code) DEBUG PRINT(.\out_file\Strategy.lst) OBJECT(.\out_file\Strategy.obj) 

stmt  level    source

    1          #include "Strategy.h"
    2          unsigned int if_time=0;
    3          unsigned int if2_time=0;
    4          unsigned int Continue_Time=0;
    5          unsigned char Enter_Flag_Left=0;
    6          unsigned char Cycle_Stat=EXIT;
    7          
    8          unsigned char Road_Stat=Short_Str;
    9          
   10          unsigned int Short_Time=0;
   11          unsigned int Long_Time=0;
   12          unsigned int Bend_Time=0;
   13          unsigned int SLOW_Time=0;
   14          unsigned int Accel_Time=0;
   15          
   16          int Wait_Time = 0;
   17          
   18          unsigned int Entern_Flag_Time=0;
   19          unsigned int Entern_Delay_Time=0;
   20          unsigned int Entern_Continue_Time=0;
   21          int turn_Value=0;
   22          int Mode_Flag=0;
   23          
   24          int angle = 0;
   25          //环岛判断
   26          void if_Cycle(void)
   27          {
   28   1              if(Wait_Time>0)
   29   1              {
   30   2                      Wait_Time--;
   31   2                      return;
   32   2              }
   33   1              else
   34   1              {
   35   2                      switch(Cycle_Stat)
   36   2                      {
   37   3                              case EXIT:
   38   3                              {
   39   4                                      Buzzer_OFF();
   40   4                                      if(ADC_2==1023 || ADC_3==1023 )
   41   4                                      {
   42   5                                              if_time++;
   43   5                                              if(if_time>Entern_Flag_Time)
   44   5                                              {
   45   6                                                      Cycle_Stat=APPROACH;
   46   6                                                      if_time=0;
   47   6                                              }
   48   5                                      }
   49   4                                      else
   50   4                                      {
   51   5                                              if_time=0;
   52   5                                      }
   53   4                                      break;
   54   4                              }
   55   3                              case APPROACH:
   56   3                              {
   57   4                                              if2_time++;
C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 2   

   58   4                                              if(if2_time>Entern_Delay_Time)
   59   4                                              {
   60   5                                                      Cycle_Stat=Left_ENTER;
   61   5                                                      angle=0;
   62   5                                                      if2_time=0;
   63   5                                              }
   64   4                                      break;
   65   4                              }
   66   3                              case Left_ENTER:
   67   3                              {
   68   4                                      Enter_Flag_Left=1;
   69   4                                      Buzzer_ON();
   70   4                                      Continue_Time++;
   71   4      //                              angle+=imu963ra_gyro_y/100;
   72   4                                      if(Continue_Time>Entern_Continue_Time)//abs(angle)>Turn_Angle*10
   73   4                                      {
   74   5                                              Cycle_Stat=EXIT;
   75   5                                              Wait_Time = 200;
   76   5                                              Continue_Time = 0;  //
   77   5                                              Enter_Flag_Left = 0;     //
   78   5                                      }
   79   4                                      break;
   80   4                              }
   81   3                              default :
   82   3                              {
   83   4                                      CAR_STOP();
   84   4                                      break;
   85   4                              }
   86   3                      }
   87   2              }
   88   1      
   89   1      }
   90          //切弯补丁
   91          int Help_turn()
   92          {
   93   1              int left  = ADC_1 + ADC_2;
   94   1              int right = ADC_3 + ADC_4;
   95   1              if (left < 200 && right < 200)
   96   1              {
   97   2                      // 同时满足，取较小一侧优先
   98   2                      if (left < right)
   99   2                              return -50;   // 左
  100   2                      else
  101   2                              return 50;    // 右
  102   2              }
  103   1              else if (left < 200)
  104   1              {
  105   2                      return -50;   // 左
  106   2              }
  107   1              else if (right < 200)
  108   1              {
  109   2                      return 50;    // 右
  110   2              }
  111   1              else
  112   1              {
  113   2                      return 0;     // 不转
  114   2              }
  115   1      }
  116          void Help_turn2(int temp, int value, int ADC_Flag)
  117          {
  118   1          static int last_dir = 0;    // -1 左，+1 右，0 未定
  119   1          static int first_double = 1; // 是否是第一次进入“双小”状态
  120   1      
  121   1          int left  = ADC_1 + ADC_2;
  122   1          int right = ADC_3 + ADC_4;
  123   1              int target=0;
C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 3   

  124   1              
  125   1              static float smooth_temp = 0;
  126   1          const int delta = 30;  // 左右接近的最小差值门限
  127   1              const float smooth=0.4;
  128   1              if(left < ADC_Flag || right < ADC_Flag)
  129   1              {
  130   2                      if (left < ADC_Flag && right < ADC_Flag)
  131   2                      {
  132   3                              if (first_double) // ★第一次双小
  133   3                              {
  134   4                                      if (left < right)
  135   4                                      {
  136   5                                              target = -value;   // 左
  137   5                                              last_dir = -1;
  138   5                                      }
  139   4                                      else
  140   4                                      {
  141   5                                              target = value;    // 右
  142   5                                              last_dir = 1;
  143   5                                      }
  144   4                                      first_double = 0; // 标记已经处理过第一次
  145   4                              }
  146   3                              else // ★后续双小
  147   3                              {
  148   4                                      if (abs(left - right) < delta)
  149   4                                      {
  150   5                                              // 按照上次方向走
  151   5                                              if (last_dir == -1) target = -value;
  152   5                                              else if (last_dir == 1) target = value;
  153   5                                              else target = value; // 默认
  154   5                                      }
  155   4                                      else if (left < right)
  156   4                                      {
  157   5                                              target = -value;
  158   5                                              last_dir = -1;
  159   5                                      }
  160   4                                      else
  161   4                                      {
  162   5                                              target = value;
  163   5                                              last_dir = 1;
  164   5                                      }
  165   4                              }
  166   3                      }
  167   2                      else if (left < ADC_Flag)
  168   2                      {
  169   3                              target = -value;
  170   3                              last_dir = -1;
  171   3                              first_double = 1; // 重置，下次再遇到“双小”时重新走第一次逻辑
  172   3                      }
  173   2                      else
  174   2                      {
  175   3                              target = value;
  176   3                              last_dir = 1;
  177   3                              first_double = 1; // 同上
  178   3                      }
  179   2                      smooth_temp = smooth_temp * (1 - smooth) + target * smooth;
  180   2                      pwm_set_duty(Servo_Pwm,Servo_Mide+smooth_temp);
  181   2              }
  182   1              else 
  183   1              {
  184   2                      if(abs(smooth_temp-temp)<200)
  185   2                      {
  186   3                              smooth_temp = temp;
  187   3                              pwm_set_duty(Servo_Pwm,Servo_Mide+temp);
  188   3                      }
  189   2                      else
C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 4   

  190   2                      {
  191   3                              smooth_temp = smooth_temp * (1 - smooth) + temp * smooth;
  192   3                              pwm_set_duty(Servo_Pwm,Servo_Mide+smooth_temp);
  193   3                      }
  194   2              }
  195   1      }
  196          
  197          void Help_turn3(int* temp, int value, int value2,int ADC_Flag ,int ADC_Flag2)
  198          {
  199   1              //value2>value1,ADC_Flag1>ADC_Flag2
  200   1          static int last_dir = 0;    // -1 左，+1 右，0 未定
  201   1          static int first_double = 1; // 是否是第一次进入“双小”状态
  202   1          int left  = ADC_1 + ADC_2;
  203   1          int right = ADC_3 + ADC_4;
  204   1              float K = (float)(value2 - value) / (ADC_Flag - ADC_Flag2);
  205   1          const int delta = 30;  // 左右接近的最小差值门限
  206   1      
  207   1          if (left < ADC_Flag && right < ADC_Flag)
  208   1          {
  209   2                      if (left < ADC_Flag2 && right < ADC_Flag2)
  210   2                      {
  211   3                              if (first_double) // ★第一次双小
  212   3                              {
  213   4                                      if (left < right)
  214   4                                      {
  215   5                                              *temp = -value2;   // 左
  216   5                                              last_dir = -1;
  217   5                                      }
  218   4                                      else
  219   4                                      {
  220   5                                              *temp = value2;    // 右
  221   5                                              last_dir = 1;
  222   5                                      }
  223   4                                      first_double = 0; // 标记已经处理过第一次
  224   4                              }
  225   3                              else // ★后续双小
  226   3                              {
  227   4                                      if (abs(left - right) < delta)
  228   4                                      {
  229   5                                              // 按照上次方向走
  230   5                                              if (last_dir == -1) *temp = -value2;
  231   5                                              else if (last_dir == 1) *temp = value2;
  232   5                                              else *temp = value2; // 默认
  233   5                                                  // 向左转
  234   5            // 向右转
  235   5                                      }
  236   4                                      else if (left < right)
  237   4                                      {
  238   5                                              *temp = -value2;
  239   5                                              last_dir = -1;
  240   5                                      }
  241   4                                      else
  242   4                                      {
  243   5                                              *temp = value2;
  244   5                                              last_dir = 1;
  245   5                                      }
  246   4                              }
  247   3                      }
  248   2                      else if(left < ADC_Flag2)
  249   2                      {
  250   3                              *temp = -value2;
  251   3                              last_dir = -1;
  252   3                              first_double = 1; 
  253   3                      }
  254   2                      else if(right < ADC_Flag2)
  255   2                      {
C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 5   

  256   3                              *temp = value2;
  257   3                              last_dir = 1;
  258   3                              first_double = 1; // 同上
  259   3                      }
  260   2                      else
  261   2                      {
  262   3                              if (abs(left - right) < delta)
  263   3                              {
  264   4                                      // 按照上次方向走
  265   4                                      if (last_dir == -1) *temp = -value;
  266   4                                      else if (last_dir == 1) *temp = value;
  267   4                                      else *temp = value; 
  268   4                              }
  269   3      //                      else if (left < right)
  270   3      //                      {
  271   3      //                              *temp = -(value + (ADC_Flag - left) * K);
  272   3      //                              last_dir = -1;
  273   3      //                              first_double = 1; 
  274   3      //                      }
  275   3      //                      else
  276   3      //                      {
  277   3      //                              *temp = value + (ADC_Flag - right) * K;
  278   3      //                              last_dir = 1;
  279   3      //                              first_double = 1; 
  280   3      //                      }
  281   3                      }
  282   2          }
  283   1          else if (left < ADC_Flag)
  284   1          {
  285   2              *temp = -(value + (ADC_Flag - left) * K);
  286   2                      last_dir = -1;
  287   2                      first_double = 1; 
  288   2          }
  289   1          else if (right < ADC_Flag)
  290   1          {
  291   2                      *temp = value + (ADC_Flag - right) * K;
  292   2                      last_dir = 1;
  293   2                      first_double = 1; 
  294   2          }
  295   1      }
  296          
  297          int Help_turn_Two(int temp, int value, int value2, int ADC_Flag, int ADC_Flag2)
  298          {
  299   1          int left  = ADC_1 + ADC_2;
  300   1          int right = ADC_3 + ADC_4;
  301   1      
  302   1          // -------- 第一组阈值判断 --------
  303   1          if (left < ADC_Flag && right < ADC_Flag)
  304   1          {
  305   2              return (left < right) ? (Servo_Mide - value) : (Servo_Mide + value);
  306   2          }
  307   1          else if (left < ADC_Flag)
  308   1          {
  309   2              return Servo_Mide - value;
  310   2          }
  311   1          else if (right < ADC_Flag)
  312   1          {
  313   2              return Servo_Mide + value;
  314   2          }
  315   1      
  316   1          // -------- 第二组阈值判断 --------
  317   1          if (left < ADC_Flag2 && right < ADC_Flag2)
  318   1          {
  319   2              return (left < right) ? (Servo_Mide - value2) : (Servo_Mide + value2);
  320   2          }
  321   1          else if (left < ADC_Flag2)
C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 6   

  322   1          {
  323   2              return Servo_Mide - value2;
  324   2          }
  325   1          else if (right < ADC_Flag2)
  326   1          {
  327   2              return Servo_Mide + value2;
  328   2          }
  329   1      
  330   1          // -------- 都不满足，返回原值 --------
  331   1          return temp;
  332   1      }
  333          
  334          int State_of_road(void)
  335          {
  336   1              switch(Road_Stat)
  337   1              {
  338   2                      case Short_Str:
  339   2                      {
  340   3                              Motor_Update_Smooth(Short_add);
  341   3                              if(abs(dajiao)<Stright_Flag_Value)
  342   3                              {
  343   4                                      Long_Time++;
  344   4                                      Bend_Time=0;
  345   4                                      if(Long_Time>Long_Judge_Time)
  346   4                                      {
  347   5                                              Long_Time=0;
  348   5                                              Road_Stat=Long_Str;
  349   5                                      }
  350   4                              }
  351   3                              else
  352   3                              {
  353   4                                      Long_Time=0;
  354   4                                      Bend_Time++;
  355   4                                      {
  356   5                                              if(Bend_Time>Bend_Judge_Time)
  357   5                                              {
  358   6                                                      Bend_Time=0;
  359   6                                                      Road_Stat=Short_Bend;
  360   6                                              }
  361   5                                      }
  362   4                              }
  363   3                              return Short_add;
  364   3                              break;
  365   3                      }
  366   2                      case Long_Str:
  367   2                      {
  368   3                              Motor_Update_Smooth(Long_add);
  369   3                              Accel_Time++;
  370   3                              if(abs(dajiao)>Bend_Flag_Value)
  371   3                              {
  372   4                                      Bend_Time++;
  373   4                                      if(Bend_Time>Bend_Judge_Time)
  374   4                                      {
  375   5                                              if(Accel_Time>150)//加速时间1.5s
  376   5                                              {
  377   6                                                      Road_Stat=Long_Bend;
  378   6                                                      SLOW_Time = 0;
  379   6                                              }
  380   5                                              else
  381   5                                              {
  382   6                                                      Road_Stat=Short_Bend;
  383   6                                              }
  384   5                                              Bend_Time=0;
  385   5                                              Accel_Time=0;
  386   5                                      }
  387   4                              }
C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 7   

  388   3                              else
  389   3                              {
  390   4                                      Bend_Time=0;
  391   4                              }
  392   3                              return Long_add;
  393   3                              break;
  394   3                      }
  395   2                      case Short_Bend:
  396   2                      {
  397   3                              Motor_Update_Smooth(Bend_speed);
  398   3                              if(abs(dajiao)>Bend_Flag_Value)
  399   3                              {
  400   4                                      Short_Time=0;
  401   4                              }
  402   3                              else
  403   3                              {
  404   4                                      Short_Time++;
  405   4                                      if(Short_Time>Short_Judge_Time)
  406   4                                      {
  407   5                                              Short_Time=0;
  408   5                                              Road_Stat=Short_Str;
  409   5                                      }
  410   4                              }
  411   3                              return Bend_speed;
  412   3                              break;
  413   3                      }
  414   2                      case Long_Bend:
  415   2                      {
  416   3                              SLOW_Time++;
  417   3                              if(SLOW_Time>L_Turn_B_Slow_Time)
  418   3                              {
  419   4                                      Buzzer_OFF();
  420   4                                      Motor_Update_Smooth(Bend_speed);//弯道速度
  421   4                              }
  422   3                              else
  423   3                              {
  424   4                                      Buzzer_ON();
  425   4                                      
  426   4                                      Motor_Update_Smooth(L_Turn_B_Slow_Value);//减速
  427   4                              }
  428   3                              //检查是否回到了直道
  429   3                              if(abs(dajiao)<Bend_Flag_Value)
  430   3                              {
  431   4                                      Short_Time++;
  432   4                                      if(Short_Time>Short_Judge_Time)
  433   4                                      {
  434   5                                              Buzzer_OFF();
  435   5                                              Short_Time=0;
  436   5                                              SLOW_Time=0;
  437   5                                              Road_Stat=Short_Str;
  438   5                                      }
  439   4                                      
  440   4                              }
  441   3                              else
  442   3                              {
  443   4                                      Short_Time=0;
  444   4                              }
  445   3                              if(SLOW_Time>L_Turn_B_Slow_Time)
  446   3                              {
  447   4                                      return Bend_speed;
  448   4                              }
  449   3                              else
  450   3                              {
  451   4                                      return L_Turn_B_Slow_Value;
  452   4                              }
  453   3                              
C251 COMPILER V5.60.0,  Strategy                                                           24/10/25  20:12:29  PAGE 8   

  454   3                              break;
  455   3                      }
  456   2                      default :
  457   2                      {
  458   3                              CAR_STOP();
  459   3                              return 0;
  460   3                              break;
  461   3                      }
  462   2              
  463   2              }
  464   1      }
  465          
  466          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2507     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        45         10
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       160     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
