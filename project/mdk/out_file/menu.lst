C251 COMPILER V5.60.0,  menu                                                               29/09/25  00:12:10  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\out_file\menu.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\menu.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) BRO
                    -WSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;.
                    -.\user;..\code) DEBUG PRINT(.\out_file\menu.lst) OBJECT(.\out_file\menu.obj) 

stmt  level    source

    1          #include "menu.h"
    2          #include <stdio.h>
    3          unsigned char Key;//用于接受键码值
    4          char Key3_count=0;      //记录按下Key3的次数
    5          char Start_Show_Row=0;  //从结构体的哪一行开始显示
    6          float bujin=1;          //步进值
    7          char Flag=1;            //行数标志位
    8          char mode=0;            //mode=1为锁定模式
    9          char i,j;                 //用于循环
   10          unsigned char Show_image_mode=0;
   11          unsigned char Save_Flag=0;
   12          //struct Menu *Pin=&Page[0];//灵活指针
   13          /*
   14           * 快捷设置子菜单的函数
   15           * 参数1:需要设置Page[x]的地址;参数2:对应的索引号数组(-1停止)
   16           * 例子   Menu_SetChildren(&Page[0],Page0_children);  将第一页的2，3，4行的子字节设置为Page[1],Page[2],Pa
             -ge[3]
   17           * 备注   确保数组末尾为-1为结束标志位，0跳过设置
   18          */
   19          void Menu_SetChildren(struct Menu *parent, unsigned char child_indices[])
   20          {
   21   1          // 清空原有子节点
   22   1          for(i = 0; i < Page_Row_Number; i++) {
   23   2              parent->children[i] = NULL;
   24   2          }
   25   1      
   26   1          // 设置新的子节点
   27   1          for(i = 0; child_indices[i] != -1 && i < Page_Row_Number; i++)
   28   1          {
   29   2              if(child_indices[i] > 0 && child_indices[i] < Struct_Number)
   30   2              {
   31   3                  parent->children[i] = &Page[child_indices[i]];
   32   3                  parent->children[i]->father = parent;
   33   3              }
   34   2      
   35   2          }
   36   1      }
   37          
   38          void Refesh_arrow()
   39          {
   40   1              if(mode==0)
   41   1              {
   42   2                      if (Flag <= max_OLED_ROW)
   43   2                      {
   44   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(Flag-1), "<--");
   45   3                      }
   46   2                      else
   47   2                      {
   48   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(max_OLED_ROW-1), "<--");
   49   3                      }
   50   2              }
   51   1              else
   52   1              {
   53   2                      if (Flag <= max_OLED_ROW)
   54   2                      {
   55   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(Flag-1), "-->");
   56   3                      }
C251 COMPILER V5.60.0,  menu                                                               29/09/25  00:12:10  PAGE 2   

   57   2                      else
   58   2                      {
   59   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(max_OLED_ROW-1), "-->");
   60   3                      }
   61   2              }
   62   1      }
   63          
   64          void menu_display_content() 
   65          {
   66   1              for(i=0;i<max_OLED_ROW;i++)                                  //**显示逻辑**
   67   1              {
   68   2                      tft180_show_string(Show_String_x,(ROW_DISTANCE+1)*i,Pin->page[i+Start_Show_Row]);
   69   2                      if(Num[Pin->index][i+Start_Show_Row]!=-1 && Pin->children[i+Start_Show_Row]==NULL && i+Start_Show_Row!=
             -0)
   70   2                      {
   71   3                              tft180_show_float(Show_Num_x,(ROW_DISTANCE+1)*i,Num[Pin->index][i+Start_Show_Row],num_float_int,num_fl
             -oat_decimal);
   72   3                      }
   73   2              }
   74   1      }
   75          void Show_bujin()
   76          {
   77   1                      switch((int)(bujin*100))
   78   1                      {
   79   2                      case 1000:tft180_show_string(Show_bujin_x,0,"<10>  ");break;
   80   2                      case 100:tft180_show_string(Show_bujin_x,0,"<1.0> ");break;
   81   2                      case 10:tft180_show_string(Show_bujin_x,0,"<0.1> ");break;
   82   2                      case 1:tft180_show_string(Show_bujin_x,0,"<0.01>");break;
   83   2                      }
   84   1      }
   85          void handle_key1()
   86          {
   87   1              if(mode==0)                                                         //MODE=0时的逻辑
   88   1              {
   89   2                      if(Flag<Page_Row_Number)
   90   2                      {
   91   3                              Flag++;                                                         //向下滚动逻辑(Key=1)
   92   3                      }
   93   2                      if(Flag<=max_OLED_ROW)
   94   2                      {
   95   3                              tft180_show_string(Show_arrow_x,(ROW_DISTANCE+1)*(Flag-2),"   ");
   96   3                      }
   97   2                      else
   98   2                      {
   99   3                              if(Flag>max_OLED_ROW ){Start_Show_Row++;}//当Flag大于oled显示的最大行数，向下滚动；
  100   3                              if(Start_Show_Row>Page_Row_Number-max_OLED_ROW){Start_Show_Row=Page_Row_Number-max_OLED_ROW;}
  101   3                              if(Flag>Page_Row_Number){Flag=Page_Row_Number;}//防止越界产生乱码
  102   3                              tft180_clear(RGB565_WHITE);
  103   3                              menu_display_content(); 
  104   3                      }
  105   2                      Refesh_arrow();
  106   2              }
  107   1              else if(mode==1)                       //锁定状态下，Key1用于增加步进值   MODE=1时的逻辑
  108   1              {
  109   2                      Num[Pin->index][Flag-1]-=bujin;
  110   2                      Save_Flag=1;
  111   2                      menu_display_content();
  112   2                      Refesh_arrow();
  113   2              }
  114   1      }
  115          
  116          void handle_key2()
  117          {
  118   1              bujin*=10.0;
  119   1              if(bujin>10)
  120   1              {
C251 COMPILER V5.60.0,  menu                                                               29/09/25  00:12:10  PAGE 3   

  121   2                      bujin=10;
  122   2              }
  123   1              Show_bujin();
  124   1              
  125   1      }
  126          
  127          void handle_key3()
  128          {
  129   1              bujin/=10.0;
  130   1              if(bujin<0.01)
  131   1              {
  132   2                      bujin=0.01;
  133   2              }
  134   1              Show_bujin();
  135   1      }
  136          void handle_key4()
  137          {
  138   1              if(mode==1)                         //锁定状态下，Key4用于减步进值      MODE=1时的逻辑
  139   1              {
  140   2                      Num[Pin->index][Flag-1]+=bujin;
  141   2                      Save_Flag=1;
  142   2                      menu_display_content(); 
  143   2              }
  144   1              else if(mode==0)                                                 //MODE=0时的逻辑
  145   1              {
  146   2                      if(Flag>1)
  147   2                      {
  148   3                              Flag--;
  149   3                      }
  150   2                      if(Flag<max_OLED_ROW)                                          //向上滚动逻辑
  151   2                      {
  152   3                              if(Flag<0)
  153   3                              {Flag=0;}
  154   3                              tft180_show_string(Show_arrow_x,(ROW_DISTANCE+1)*(Flag),"   ");
  155   3                      }
  156   2                      else
  157   2                      {
  158   3                              if(Start_Show_Row>0){Start_Show_Row--;}
  159   3                              tft180_clear(RGB565_WHITE);
  160   3                              menu_display_content(); 
  161   3                      }
  162   2                      Refesh_arrow();
  163   2              }
  164   1      }
  165          void handle_key5()
  166          {
  167   1              Key3_count++;
  168   1          
  169   1          // 直接在按键处理函数中处理模式切换
  170   1          switch(Key3_count)
  171   1          {
  172   2                      case 1:{Key3_handle1();break;}  //当按下键码值为 3 一次的模式切换（调参模式）
  173   2                      case 2:{Key3_handle2();break;}  //当按下键码值为 3 两次的模式切换（翻动模式）
  174   2              default: break;
  175   2          }
  176   1      }
  177          void Key3_handle1()
  178          {
  179   1              mode=1;
  180   1              Refesh_arrow();
  181   1      }
  182          void Key3_handle2()
  183          {
  184   1              if(Save_Flag)
  185   1              {
  186   2                      eeprom_save_Num();
C251 COMPILER V5.60.0,  menu                                                               29/09/25  00:12:10  PAGE 4   

  187   2                      Save_Flag=0;
  188   2              }
  189   1              if((Pin->children[Flag-1])!=NULL)//进入子字节――――――进入操作
  190   1              {
  191   2                      Pin=Pin->children[Flag-1];
  192   2                      Flag=1;
  193   2                      Start_Show_Row=0;
  194   2              }
  195   1              else if(Pin->father!=NULL && Flag==1)//第一行进入父字节――――――退出操作
  196   1              {
  197   2                      Pin=Pin->father;
  198   2                      Flag=1;
  199   2                      Start_Show_Row=0;
  200   2              }
  201   1              Key3_count=0;mode=0;tft180_clear(RGB565_WHITE);                 //按两下如果没有子菜单，刷新显示
  202   1              Refesh_arrow();
  203   1              menu_display_content();
  204   1              Show_bujin();
  205   1      }
  206          /* 函数：按键控制菜单函数
  207           * 参数1：键码值
  208           * 返回值：无
  209           * 例子：menu_handle_key（Key）；
  210           */
  211          void menu_handle_key(unsigned char Flag_Key)
  212          {
  213   1      
  214   1              switch(Flag_Key)
  215   1              {
  216   2                      case 1:{handle_key1();break;}  //按下键码值为 1 按键的行为
  217   2                      case 2:{handle_key2();break;}  //按下键码值为 2 按键的行为
  218   2                      case 3:{handle_key3();break;}  //按下键码值为 3 按键的行为
  219   2                      case 4:{handle_key4();break;}  //按下键码值为 4 按键的行为
  220   2                      case 5:{handle_key5();break;}  //按下键码值为 5 按键的行为
  221   2              }
  222   1      }
  223          /*菜单初始化
  224          设置子菜单索引
  225          设置一开始显示的画面
  226          */
  227          void menu_Init()
  228          {
  229   1              Menu_SetChildren(&Page[0],Page0_children);//设定子字节
  230   1              Menu_SetChildren(&Page[5],Page5_children);//设定子字节
  231   1              Refesh_arrow();
  232   1              menu_display_content();
  233   1              Show_bujin();
  234   1              
  235   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1661     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        13     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
C251 COMPILER V5.60.0,  menu                                                               29/09/25  00:12:10  PAGE 5   

  const size           =    ------     ------
  hconst size          =        85     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
