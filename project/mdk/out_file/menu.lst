C251 COMPILER V5.60.0,  menu                                                               26/09/25  17:50:09  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\out_file\menu.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\menu.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) BRO
                    -WSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;.
                    -.\user;..\code) DEBUG PRINT(.\out_file\menu.lst) OBJECT(.\out_file\menu.obj) 

stmt  level    source

    1          #include "menu.h"
    2          #include <stdio.h>
    3          unsigned char Key;//用于接受键码值
    4          char Key3_count=0;      //记录按下Key3的次数
    5          char Start_Show_Row=0;  //从结构体的哪一行开始显示
    6          float bujin=1;          //步进值
    7          char Flag=1;            //行数标志位
    8          char mode=0;            //mode=1为锁定模式
    9          char i,j;                 //用于循环
   10          unsigned char Show_image_mode=0;
   11          unsigned char Save_Flag=0;
   12          //struct Menu *Pin=&Page[0];//灵活指针
   13          /*
   14           * 快捷设置子菜单的函数
   15           * 参数1:需要设置Page[x]的地址;参数2:对应的索引号数组(-1停止)
   16           * 例子   Menu_SetChildren(&Page[0],Page0_children);  将第一页的2，3，4行的子字节设置为Page[1],Page[2],Pa
             -ge[3]
   17           * 备注   确保数组末尾为-1为结束标志位，0跳过设置
   18          */
   19          void Menu_SetChildren(struct Menu *parent, unsigned char child_indices[])
   20          {
   21   1          // 清空原有子节点
   22   1          for(i = 0; i < Page_Row_Number; i++) {
   23   2              parent->children[i] = NULL;
   24   2          }
   25   1      
   26   1          // 设置新的子节点
   27   1          for(i = 0; child_indices[i] != -1 && i < Page_Row_Number; i++)
   28   1          {
   29   2              if(child_indices[i] > 0 && child_indices[i] < Struct_Number)
   30   2              {
   31   3                  parent->children[i] = &Page[child_indices[i]];
   32   3                  parent->children[i]->father = parent;
   33   3              }
   34   2      
   35   2          }
   36   1      }
   37          
   38          void Refesh_arrow()
   39          {
   40   1              if(mode==0)
   41   1              {
   42   2                      if (Flag <= max_OLED_ROW)
   43   2                      {
   44   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(Flag-1), "<");
   45   3                      }
   46   2                      else
   47   2                      {
   48   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(max_OLED_ROW-1), "<");
   49   3                      }
   50   2              }
   51   1              else
   52   1              {
   53   2                      if (Flag <= max_OLED_ROW)
   54   2                      {
   55   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(Flag-1), ">");
   56   3                      }
C251 COMPILER V5.60.0,  menu                                                               26/09/25  17:50:09  PAGE 2   

   57   2                      else
   58   2                      {
   59   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(max_OLED_ROW-1), ">");
   60   3                      }
   61   2              }
   62   1      }
   63          
   64          void menu_display_content() 
   65          {
   66   1              for(i=0;i<max_OLED_ROW;i++)                                  //**显示逻辑**
   67   1              {
   68   2                      tft180_show_string(Show_String_x,(ROW_DISTANCE+1)*i,Pin->page[i+Start_Show_Row]);
   69   2                      if(Num[Pin->index][i+Start_Show_Row]!=-1 && Pin->children[i+Start_Show_Row]==NULL && i+Start_Show_Row!=
             -0)
   70   2                      {
   71   3                              tft180_show_float(Show_Num_x,(ROW_DISTANCE+1)*i,Num[Pin->index][i+Start_Show_Row],num_float_int,num_fl
             -oat_decimal);
   72   3                      }
   73   2              }
   74   1      }
   75          
   76          void handle_key1()
   77          {
   78   1              if(mode==0)                                                         //MODE=0时的逻辑
   79   1              {
   80   2                      if(Flag<Page_Row_Number)
   81   2                      {
   82   3                              Flag++;                                                         //向下滚动逻辑(Key=1)
   83   3                      }
   84   2                      if(Flag<=max_OLED_ROW)
   85   2                      {
   86   3                              tft180_show_string(Show_arrow_x,(ROW_DISTANCE+1)*(Flag-2)," ");
   87   3                      }
   88   2                      else
   89   2                      {
   90   3                              if(Flag>max_OLED_ROW ){Start_Show_Row++;}//当Flag大于oled显示的最大行数，向下滚动；
   91   3                              if(Start_Show_Row>Page_Row_Number-max_OLED_ROW){Start_Show_Row=Page_Row_Number-max_OLED_ROW;}
   92   3                              if(Flag>Page_Row_Number){Flag=Page_Row_Number;}//防止越界产生乱码
   93   3                              tft180_clear(RGB565_WHITE);
   94   3                              menu_display_content(); 
   95   3                      }
   96   2                      Refesh_arrow();
   97   2              }
   98   1              else if(mode==1)                       //锁定状态下，Key1用于增加步进值   MODE=1时的逻辑
   99   1              {
  100   2                      Num[Pin->index][Flag-1]+=bujin;
  101   2                      Save_Flag=1;
  102   2                      menu_display_content();
  103   2                      Refesh_arrow();
  104   2              }
  105   1      }
  106          
  107          void handle_key2()
  108          {
  109   1              if(mode==0)                                                         //MODE=0时的逻辑
  110   1              {
  111   2      
  112   2              }
  113   1              else if(mode==1)                    //修改步进值{0.01->10}      改变MODE=1时的逻辑
  114   1              {
  115   2                      if(bujin<=0.01)
  116   2                      {
  117   3                              bujin=100;
  118   3                      }
  119   2                      bujin/=10.0;
  120   2                      if(Flag<max_OLED_ROW)
C251 COMPILER V5.60.0,  menu                                                               26/09/25  17:50:09  PAGE 3   

  121   2                      {
  122   3                              switch((int)(bujin*100))
  123   3                              {
  124   4                              case 1000:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(Flag-1),"10  ");break;
  125   4                              case 100:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(Flag-1),"1.0 ");break;
  126   4                              case 10:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(Flag-1),"0.1 ");break;
  127   4                              case 1:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(Flag-1),"0.01");break;
  128   4                              }
  129   3                      }
  130   2                      else
  131   2                      {
  132   3                              switch((int)(bujin*100))
  133   3                              {
  134   4                              case 1000:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(max_OLED_ROW-1),"10  ");break;
  135   4                              case 100:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(max_OLED_ROW-1),"1.0 ");break;
  136   4                              case 10:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(max_OLED_ROW-1),"0.1 ");break;
  137   4                              case 1:tft180_show_string(Show_bujin_x,(ROW_DISTANCE+1)*(max_OLED_ROW-1),"0.01");break;
  138   4                              }
  139   3                      }
  140   2              }
  141   1      }
  142          
  143          void handle_key3()
  144          {
  145   1          Key3_count++;
  146   1          
  147   1          // 直接在按键处理函数中处理模式切换
  148   1          switch(Key3_count)
  149   1          {
  150   2                      case 1:{Key3_handle1();break;}  //当按下键码值为 3 一次的模式切换（调参模式）
  151   2                      case 2:{Key3_handle2();break;}  //当按下键码值为 3 两次的模式切换（翻动模式）
  152   2              default: break;
  153   2          }
  154   1      }
  155          void handle_key4()
  156          {
  157   1              if(mode==1)                         //锁定状态下，Key4用于减步进值      MODE=1时的逻辑
  158   1              {
  159   2                      Num[Pin->index][Flag-1]-=bujin;
  160   2                      Save_Flag=1;
  161   2                      menu_display_content(); 
  162   2              }
  163   1              else if(mode==0)                                                 //MODE=0时的逻辑
  164   1              {
  165   2                      if(Flag>1)
  166   2                      {
  167   3                              Flag--;
  168   3                      }
  169   2                      if(Flag<max_OLED_ROW)                                          //向上滚动逻辑
  170   2                      {
  171   3                              if(Flag<0)
  172   3                              {Flag=0;}
  173   3                              tft180_show_string(Show_arrow_x,(ROW_DISTANCE+1)*(Flag)," ");
  174   3                      }
  175   2                      else
  176   2                      {
  177   3                              if(Start_Show_Row>0){Start_Show_Row--;}
  178   3                              tft180_clear(RGB565_WHITE);
  179   3                              menu_display_content(); 
  180   3                      }
  181   2                      Refesh_arrow();
  182   2              }
  183   1      }
  184          void Key3_handle1()
  185          {
  186   1              mode=1;
C251 COMPILER V5.60.0,  menu                                                               26/09/25  17:50:09  PAGE 4   

  187   1              Refesh_arrow();
  188   1      }
  189          void Key3_handle2()
  190          {
  191   1              if(Save_Flag)
  192   1              {
  193   2                      eeprom_save_Num();
  194   2                      Save_Flag=0;
  195   2              }
  196   1              if((Pin->children[Flag-1])!=NULL)//进入子字节――――――进入操作
  197   1              {
  198   2                      Pin=Pin->children[Flag-1];
  199   2                      Flag=1;
  200   2                      Start_Show_Row=0;
  201   2              }
  202   1              else if(Pin->father!=NULL && Flag==1)//第一行进入父字节――――――退出操作
  203   1              {
  204   2                      Pin=Pin->father;
  205   2                      Flag=1;
  206   2                      Start_Show_Row=0;
  207   2              }
  208   1              Key3_count=0;mode=0;tft180_clear(RGB565_WHITE);                 //按两下如果没有子菜单，刷新显示
  209   1              Refesh_arrow();
  210   1              menu_display_content();
  211   1      }
  212          /* 函数：按键控制菜单函数
  213           * 参数1：键码值
  214           * 返回值：无
  215           * 例子：menu_handle_key（Key）；
  216           */
  217          void menu_handle_key(unsigned char Flag_Key)
  218          {
  219   1      
  220   1              switch(Flag_Key)
  221   1              {
  222   2                      case 1:{handle_key1();break;}  //按下键码值为 1 按键的行为
  223   2                      case 2:{handle_key2();break;}  //按下键码值为 2 按键的行为
  224   2                      case 3:{handle_key3();break;}  //按下键码值为 3 按键的行为
  225   2                      case 4:{handle_key4();break;}  //按下键码值为 4 按键的行为
  226   2              }
  227   1      }
  228          /*菜单初始化
  229          设置子菜单索引
  230          设置一开始显示的画面
  231          */
  232          void menu_Init()
  233          {
  234   1              Menu_SetChildren(&Page[0],Page0_children);//设定子字节
  235   1              Menu_SetChildren(&Page[5],Page5_children);//设定子字节
  236   1              Refesh_arrow();
  237   1              menu_display_content();
  238   1              
  239   1              
  240   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1797     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        13     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
C251 COMPILER V5.60.0,  menu                                                               26/09/25  17:50:09  PAGE 5   

  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        71     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
