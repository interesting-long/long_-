C251 COMPILER V5.60.0,  menu                                                               29/09/25  10:58:35  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\out_file\menu.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\code\menu.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(3,SIZE) BRO
                    -WSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;.
                    -.\user;..\code) DEBUG PRINT(.\out_file\menu.lst) OBJECT(.\out_file\menu.obj) 

stmt  level    source

    1          #include "menu.h"
    2          #include <stdio.h>
    3          unsigned char Key;//用于接受键码值
    4          char Key3_count=0;      //记录按下Key3的次数
    5          char Start_Show_Row=0;  //从结构体的哪一行开始显示
    6          float bujin=1;          //步进值
    7          char Flag=1;            //行数标志位
    8          char mode=0;            //mode=1为锁定模式
    9          char i,j;                 //用于循环
   10          unsigned char Show_image_mode=0;
   11          unsigned char Save_Flag=0;
   12          //struct Menu *Pin=&Page[0];//灵活指针
   13          /*
   14           * 快捷设置子菜单的函数
   15           * 参数1:需要设置Page[x]的地址;参数2:对应的索引号数组(-1停止)
   16           * 例子   Menu_SetChildren(&Page[0],Page0_children);  将第一页的2，3，4行的子字节设置为Page[1],Page[2],Pa
             -ge[3]
   17           * 备注   确保数组末尾为-1为结束标志位，0跳过设置
   18          */
   19          void Menu_SetChildren(struct Menu *parent, unsigned char child_indices[])
   20          {
   21   1          // 清空原有子节点
   22   1          for(i = 0; i < Page_Row_Number; i++) {
   23   2              parent->children[i] = NULL;
   24   2          }
   25   1      
   26   1          // 设置新的子节点
   27   1          for(i = 0; child_indices[i] != -1 && i < Page_Row_Number; i++)
   28   1          {
   29   2              if(child_indices[i] > 0 && child_indices[i] < Struct_Number)
   30   2              {
   31   3                  parent->children[i] = &Page[child_indices[i]];
   32   3                  parent->children[i]->father = parent;
   33   3              }
   34   2      
   35   2          }
   36   1      }
   37          
   38          void Refesh_arrow()
   39          {
   40   1              if(mode==0)
   41   1              {
   42   2                      if (Flag <= max_OLED_ROW)
   43   2                      {
   44   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(Flag-1), "<--");
   45   3                      }
   46   2                      else
   47   2                      {
   48   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(max_OLED_ROW-1), "<--");
   49   3                      }
   50   2              }
   51   1              else
   52   1              {
   53   2                      if (Flag <= max_OLED_ROW)
   54   2                      {
   55   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(Flag-1), "-->");
   56   3                      }
C251 COMPILER V5.60.0,  menu                                                               29/09/25  10:58:35  PAGE 2   

   57   2                      else
   58   2                      {
   59   3                              tft180_show_string(Show_arrow_x, (ROW_DISTANCE+1)*(max_OLED_ROW-1), "-->");
   60   3                      }
   61   2              }
   62   1      }
   63          
   64          void menu_display_content() 
   65          {
   66   1              for(i=0;i<max_OLED_ROW;i++)                                  //**显示逻辑**
   67   1              {
   68   2                      tft180_show_string(Show_String_x,(ROW_DISTANCE+1)*i,Pin->page[i+Start_Show_Row]);
   69   2                      if(Num[Pin->index][i+Start_Show_Row]!=-1 && Pin->children[i+Start_Show_Row]==NULL && i+Start_Show_Row!=
             -0)
   70   2                      {
   71   3                              tft180_show_float(Show_Num_x,(ROW_DISTANCE+1)*i,Num[Pin->index][i+Start_Show_Row],num_float_int,num_fl
             -oat_decimal);
   72   3                      }
   73   2              }
   74   1      }
   75          void Show_bujin()
   76          {
   77   1                      switch((int)(bujin*100))
   78   1                      {
   79   2                      case 1000:tft180_show_string(Show_bujin_x,0,"<10>  ");break;
   80   2                      case 100:tft180_show_string(Show_bujin_x,0,"<1.0> ");break;
   81   2                      case 10:tft180_show_string(Show_bujin_x,0,"<0.1> ");break;
   82   2                      case 1:tft180_show_string(Show_bujin_x,0,"<0.01>");break;
   83   2                      }
   84   1      }
   85          
   86          void show_all_menu()
   87          {
   88   1              tft180_clear(RGB565_WHITE);
   89   1              Refesh_arrow();
   90   1              menu_display_content();
   91   1              Show_bujin();
   92   1      }
   93          void handle_key1()
   94          {
   95   1              if(mode==0)                                                         //MODE=0时的逻辑
   96   1              {
   97   2                      if(Flag<Page_Row_Number)
   98   2                      {
   99   3                              Flag++;                                                         //向下滚动逻辑(Key=1)
  100   3                      }
  101   2                      if(Flag<=max_OLED_ROW)
  102   2                      {
  103   3                              tft180_show_string(Show_arrow_x,(ROW_DISTANCE+1)*(Flag-2),"   ");
  104   3                      }
  105   2                      else
  106   2                      {
  107   3                              if(Flag>max_OLED_ROW ){Start_Show_Row++;}//当Flag大于oled显示的最大行数，向下滚动；
  108   3                              if(Start_Show_Row>Page_Row_Number-max_OLED_ROW){Start_Show_Row=Page_Row_Number-max_OLED_ROW;}
  109   3                              if(Flag>Page_Row_Number){Flag=Page_Row_Number;}//防止越界产生乱码
  110   3                              tft180_clear(RGB565_WHITE);
  111   3                              menu_display_content(); 
  112   3                      }
  113   2                      Refesh_arrow();
  114   2              }
  115   1              else if(mode==1)                       //锁定状态下，Key1用于增加步进值   MODE=1时的逻辑
  116   1              {
  117   2                      Num[Pin->index][Flag-1]-=bujin;
  118   2                      Save_Flag=1;
  119   2                      menu_display_content();
  120   2                      Refesh_arrow();
C251 COMPILER V5.60.0,  menu                                                               29/09/25  10:58:35  PAGE 3   

  121   2              }
  122   1      }
  123          
  124          void handle_key2()
  125          {
  126   1              bujin*=10.0;
  127   1              if(bujin>10)
  128   1              {
  129   2                      bujin=10;
  130   2              }
  131   1              Show_bujin();
  132   1              
  133   1      }
  134          
  135          void handle_key3()
  136          {
  137   1              bujin/=10.0;
  138   1              if(bujin<0.01)
  139   1              {
  140   2                      bujin=0.01;
  141   2              }
  142   1              Show_bujin();
  143   1      }
  144          void handle_key4()
  145          {
  146   1              if(mode==1)                         //锁定状态下，Key4用于减步进值      MODE=1时的逻辑
  147   1              {
  148   2                      Num[Pin->index][Flag-1]+=bujin;
  149   2                      Save_Flag=1;
  150   2                      menu_display_content(); 
  151   2              }
  152   1              else if(mode==0)                                                 //MODE=0时的逻辑
  153   1              {
  154   2                      if(Flag>1)
  155   2                      {
  156   3                              Flag--;
  157   3                      }
  158   2                      if(Flag<max_OLED_ROW)                                          //向上滚动逻辑
  159   2                      {
  160   3                              if(Flag<0)
  161   3                              {Flag=0;}
  162   3                              tft180_show_string(Show_arrow_x,(ROW_DISTANCE+1)*(Flag),"   ");
  163   3                      }
  164   2                      else
  165   2                      {
  166   3                              if(Start_Show_Row>0){Start_Show_Row--;}
  167   3                              tft180_clear(RGB565_WHITE);
  168   3                              menu_display_content(); 
  169   3                      }
  170   2                      Refesh_arrow();
  171   2              }
  172   1      }
  173          void handle_key5()
  174          {
  175   1              Key3_count++;
  176   1          
  177   1          // 直接在按键处理函数中处理模式切换
  178   1          switch(Key3_count)
  179   1          {
  180   2                      case 1:{Key3_handle1();break;}  //当按下键码值为 3 一次的模式切换（调参模式）
  181   2                      case 2:{Key3_handle2();break;}  //当按下键码值为 3 两次的模式切换（翻动模式）
  182   2              default: break;
  183   2          }
  184   1      }
  185          void Key3_handle1()
  186          {
C251 COMPILER V5.60.0,  menu                                                               29/09/25  10:58:35  PAGE 4   

  187   1              mode=1;
  188   1              Refesh_arrow();
  189   1      }
  190          void Key3_handle2()
  191          {
  192   1              if(Save_Flag)
  193   1              {
  194   2                      eeprom_save_Num();
  195   2                      Save_Flag=0;
  196   2              }
  197   1              if((Pin->children[Flag-1])!=NULL)//进入子字节――――――进入操作
  198   1              {
  199   2                      Pin=Pin->children[Flag-1];
  200   2                      Flag=1;
  201   2                      Start_Show_Row=0;
  202   2                      Key3_count=0;mode=0;
  203   2                      show_all_menu();
  204   2              }
  205   1              else if(Pin->father!=NULL && Flag==1)//第一行进入父字节――――――退出操作
  206   1              {
  207   2                      Pin=Pin->father;
  208   2                      Flag=1;
  209   2                      Start_Show_Row=0;
  210   2                      Key3_count=0;mode=0;
  211   2                      show_all_menu();
  212   2              }
  213   1              Key3_count=0;mode=0;
  214   1              Refesh_arrow();
  215   1      }
  216          /* 函数：按键控制菜单函数
  217           * 参数1：键码值
  218           * 返回值：无
  219           * 例子：menu_handle_key（Key）；
  220           */
  221          void menu_handle_key(unsigned char Flag_Key)
  222          {
  223   1      
  224   1              switch(Flag_Key)
  225   1              {
  226   2                      case 1:{handle_key1();break;}  //按下键码值为 1 按键的行为
  227   2                      case 2:{handle_key2();break;}  //按下键码值为 2 按键的行为
  228   2                      case 3:{handle_key3();break;}  //按下键码值为 3 按键的行为
  229   2                      case 4:{handle_key4();break;}  //按下键码值为 4 按键的行为
  230   2                      case 5:{handle_key5();break;}  //按下键码值为 5 按键的行为
  231   2              }
  232   1      }
  233          /*菜单初始化
  234          设置子菜单索引
  235          设置一开始显示的画面
  236          */
  237          void menu_Init()
  238          {
  239   1              Menu_SetChildren(&Page[0],Page0_children);//设定子字节
  240   1              Menu_SetChildren(&Page[5],Page5_children);//设定子字节
  241   1              Refesh_arrow();
  242   1              menu_display_content();
  243   1              Show_bujin();
  244   1              
  245   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1691     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
C251 COMPILER V5.60.0,  menu                                                               29/09/25  10:58:35  PAGE 5   

  pdata size           =    ------     ------
  xdata size           =        13     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        85     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
